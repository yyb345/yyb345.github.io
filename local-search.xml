<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Something About Nginx</title>
    <link href="/NginxNotes/"/>
    <url>/NginxNotes/</url>
    
    <content type="html"><![CDATA[<p>Something about Nginx</p><h2 id="1-Nginx-as-a-Traffic-Gateway"><a href="#1-Nginx-as-a-Traffic-Gateway" class="headerlink" title="1. Nginx as a Traffic Gateway"></a>1. Nginx as a Traffic Gateway</h2><ol><li><strong>Definition</strong><ul><li>Nginx is primarily known as a high‑performance <strong>HTTP server</strong>, <strong>reverse proxy</strong>, and <strong>load balancer</strong>.</li><li>Written in <strong>C</strong> for efficiency and portability.</li><li>Operates primarily at the <strong>application layer (Layer 7)</strong> when performing load balancing (though it can also handle TCP&#x2F;UDP streams in later versions).</li></ul></li><li><strong>Key Features</strong><ul><li><strong>Reverse Proxy</strong>: Nginx can sit in front of web servers or applications, intercepting and forwarding client requests, and can perform caching, SSL termination, compression, etc.</li><li><strong>Load Balancing</strong>: Distributes incoming requests across multiple backend servers, supporting algorithms like round-robin, IP hash, least connections, etc.</li><li><strong>High Concurrency &amp; Low Memory Usage</strong>: Nginx uses an asynchronous, event-driven model that scales extremely well under high traffic.</li><li><strong>Caching</strong>: Can cache both static and dynamic content to improve performance.</li><li><strong>One Master Process + Multiple Worker Processes</strong>: This architecture helps isolate the manager and configuration tasks (master) from the actual I&#x2F;O handling (workers).</li></ul></li><li><strong>Event-Driven, Asynchronous I&#x2F;O</strong><ul><li>Nginx relies on <strong>epoll</strong> (on Linux) or similar mechanisms (kqueue on FreeBSD, event ports on Solaris, etc.) to handle a large number of simultaneous connections in a non-blocking manner.</li></ul></li></ol><hr><h2 id="2-Nginx-Deployment-Architecture"><a href="#2-Nginx-Deployment-Architecture" class="headerlink" title="2. Nginx Deployment Architecture"></a>2. Nginx Deployment Architecture</h2><ol><li><strong>Master Process</strong><ul><li>Reads and evaluates configuration files.</li><li>Spawns, reconfigures, or terminates worker processes.</li><li>Does not handle incoming traffic directly; instead, it delegates that work to the worker processes.</li></ul></li><li><strong>Worker Processes</strong><ul><li>Each worker process handles incoming connections using <strong>asynchronous I&#x2F;O</strong>.</li><li>The worker processes all share the same listening sockets (set up by the master), and the OS distributes incoming connections among these workers.</li><li>Because of the event-driven approach, each worker can handle thousands of concurrent connections without spawning new threads or processes for each connection.</li></ul></li><li><strong>Multi-Worker Model</strong><ul><li>Typically, you configure 1 worker per CPU core, but this can vary based on the workload.</li><li>Workers can process many requests in parallel via non-blocking I&#x2F;O.</li></ul></li></ol><hr><h2 id="3-Comparison-with-HAproxy-and-LVS"><a href="#3-Comparison-with-HAproxy-and-LVS" class="headerlink" title="3. Comparison with HAproxy and LVS"></a>3. Comparison with HAproxy and LVS</h2><p>There are three popular load balancing&#x2F;reverse proxy tools: <strong>Nginx</strong>, <strong>HAProxy</strong>, and <strong>LVS</strong>. Although they may overlap in functionality, each has strengths and is often used in different scenarios:</p><ol><li><strong>Nginx</strong><ul><li><strong>Layer 7</strong> focused (application layer), though it can also do TCP&#x2F;UDP (Layer 4) in newer versions.</li><li>Excellent for HTTP and HTTPS load balancing, reverse proxying, caching, SSL termination, and compression.</li><li>Can serve static files directly.</li><li>Configuration can be more extensive (complex rewrites, caching rules, etc.).</li></ul></li><li><strong>HAProxy</strong><ul><li>Primarily focused on <strong>Layer 4</strong> (TCP) and <strong>Layer 7</strong> (HTTP) load balancing.</li><li>Known for very high performance, stable load balancing features, and advanced metrics.</li><li>Lacks some built-in features that Nginx has (like a native web server for static files or easy caching), but it’s extremely efficient and widely used for pure load balancing.</li></ul></li><li><strong>LVS (Linux Virtual Server)</strong><ul><li>Operates mostly at <strong>Layer 4</strong> (Transport layer).</li><li>Implemented in the Linux kernel (IPVS module) for IP-based load balancing.</li><li>Highly efficient for raw TCP&#x2F;UDP load balancing, but lacks Layer 7 capabilities (cannot do complex application-level logic, HTTP rewrites, etc.).</li><li>Often used in very large-scale deployments where advanced application-layer features are not required.</li></ul></li></ol><p>In summary, if you need <strong>application-level</strong> manipulation (HTTP headers, caching, rewriting) and a built-in <strong>reverse proxy</strong>, Nginx is a good choice. If you only need extremely <strong>high-performance load balancing</strong> at either Layer 4 or 7, HAProxy is often preferred. LVS is best for <strong>very large-scale Layer 4</strong> balancing scenarios when you don’t need application-layer features.</p><hr><h2 id="4-The-epoll-Model"><a href="#4-The-epoll-Model" class="headerlink" title="4. The epoll Model"></a>4. The epoll Model</h2><ol><li><strong>What is epoll?</strong><ul><li><strong>epoll</strong> is a Linux kernel system call interface for handling large numbers of file descriptors (network sockets) in an <strong>event-driven, non-blocking</strong> fashion.</li><li>It uses a readiness notification model, telling you which descriptors are “ready” for read or write without having to actively poll them all the time.</li></ul></li><li><strong>Why epoll?</strong><ul><li><strong>Scalability</strong>: With epoll, you can efficiently manage thousands (or even millions) of concurrent connections using a single or few worker threads.</li><li><strong>Performance</strong>: epoll reduces overhead because it avoids constantly scanning all connections; it only processes events for sockets that actually require attention.</li><li><strong>Memory Efficiency</strong>: epoll can be more memory-friendly compared to traditional poll&#x2F;select.</li></ul></li><li><strong>Nginx and epoll</strong><ul><li>On Linux, Nginx’s worker processes typically rely on <strong>epoll</strong> to handle incoming connections.</li><li>When an event (like a socket becoming readable) occurs, epoll notifies the worker, and the worker processes data without blocking on other I&#x2F;O operations.</li></ul></li></ol><hr><h2 id="5-Core-Components-of-Nginx"><a href="#5-Core-Components-of-Nginx" class="headerlink" title="5. Core Components of Nginx"></a>5. Core Components of Nginx</h2><ol><li><strong>Event Core</strong><ul><li>Handles the registration and delivery of events (read&#x2F;write) on network connections.</li><li>Abstracted so that different OS-level event mechanisms (epoll, kqueue, etc.) can be used.</li></ul></li><li><strong>HTTP&#x2F;Stream Modules</strong><ul><li><strong>HTTP Module</strong>: Contains the main logic for handling HTTP requests, parsing headers, implementing rewrites, etc.</li><li><strong>Stream Module</strong>: Introduced for TCP&#x2F;UDP load balancing, allowing Nginx to handle Layer 4 traffic.</li></ul></li><li><strong>Configuration System</strong><ul><li>Nginx config files (<code>nginx.conf</code>, plus various includes) define directives for modules and specify how traffic is handled.</li></ul></li><li><strong>Core Infrastructure</strong><ul><li><strong>Master Process</strong> manages worker processes, re-reading configs, and graceful restarts.</li><li><strong>Worker Processes</strong> handle the actual client connections, using the event-driven model.</li></ul></li><li><strong>Additional Modules</strong><ul><li><strong>Cache</strong>, <strong>SSL</strong>, <strong>Gzip</strong> compression, <strong>Access Control</strong>, etc.</li><li>Third-party modules can extend functionality further (e.g., Lua modules, security modules).</li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Something About CoffeChat</title>
    <link href="/coffechat/"/>
    <url>/coffechat/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In the professional world, <strong>coffee chats are a short, casual meeting to network and ask for advice</strong> from someone more experienced. While awkward to initiate, coffee chats offer huge benefits for career growth and development when done right.</p><p>This guide provides <strong>tips to successfully and politely request coffee chats</strong>, <strong>optimize the conversation</strong>, and <strong>follow up</strong> to turn meetings into meaningful connections. Let’s get started!</p><h2 id="How-to-Ask-for-a-Coffee-Chat"><a href="#How-to-Ask-for-a-Coffee-Chat" class="headerlink" title="How to Ask for a Coffee Chat"></a>How to Ask for a Coffee Chat</h2><p>The key to a <a href="https://www.simpleworkapps.com/blog/coffee-chat-email/">successful coffee chat invitation</a> is being <strong>concise, direct, and personal</strong>. Keep your initial outreach email to 2-3 paragraphs highlighting who you are, why you want to connect, and proposing a meeting.</p><p>Before reaching out, <strong>take time to research the person’s background and interests</strong>. Review their LinkedIn, published content, and past roles. This allows you to <strong>personalize your request</strong> and show you did your homework on them.</p><p>When drafting the <a href="https://www.simpleworkapps.com/blog/coffee-chat-email/">email</a>, <strong>use a warm yet professional tone</strong>. Keep it casual and conversational but avoid abbreviations like “Thx”. Proofread to fix any typos!</p><p><strong>Explain why chatting could mutually benefit you both</strong>. Share how your common experiences or interests could lead to a helpful discussion. This shows you’re not just asking for favors.</p><p>If an in-person meeting isn’t possible, <strong>suggest talking over video chat</strong> instead. Mention your availability for a 30-60 minute call via Zoom, Google Hangouts, etc.</p><p><strong>Follow up if you don’t hear back after 5-7 business days]</strong>. <a href="https://www.simpleworkapps.com/blog/coffee-chat-email/">Send a quick email</a> checking if they received your original note and restating your interest. If still no response, move on for now.</p><p>The key is keeping your outreach focused, personalized, and considerate of their time. With a genuine, well-researched request sent their way, the ball is in their court. Stay gracious if they can’t meet - not every ask results in a chat.</p><h2 id="What-to-Include-in-Your-Coffee-Chat-Request"><a href="#What-to-Include-in-Your-Coffee-Chat-Request" class="headerlink" title="What to Include in Your Coffee Chat Request"></a>What to Include in Your Coffee Chat Request</h2><p><a href="https://www.simpleworkapps.com/blog/coffee-chat/">A successful coffee chat</a> request covers four key elements: <strong>introducing yourself</strong>, <strong>explaining your goals</strong>, <strong>proposing a meeting</strong>, and <strong>expressing gratitude</strong>.</p><p>First, <strong>briefly introduce yourself</strong> and describe your background. Share details like your current job, education, past experiences and interests. This gives them context on who you are.</p><p>Next, <strong>explain why you want to connect</strong> and what you’re hoping to learn. For example, “As a recent college grad interested in a marketing career, I’d love to hear your advice on breaking into the field.” This provides helpful context.</p><p>Then, <strong>suggest a specific date, time, and location</strong> that fits your schedule. Give 2-3 options if possible, but avoid vague statements like “let me know when you’re free.” Providing details shows you value their time.</p><p>Finally, <strong>thank them for considering your invitation</strong> and acknowledge their busy schedule. For instance, “I know you have a lot of demands on your time, so I appreciate you taking the time to chat over coffee.” Gratitude and understanding go a long way.</p><p><a href="https://www.simpleworkapps.com/blog/coffee-chat-email/">Keep the request email focused on these four components</a>. Use a warm yet professional tone and avoid typos or abbreviations. With a personalized, considerate ask, you’re that much more likely to get that coffee chat booked!</p><h2 id="Making-the-Most-of-the-Coffee-Chat"><a href="#Making-the-Most-of-the-Coffee-Chat" class="headerlink" title="Making the Most of the Coffee Chat"></a>Making the Most of the Coffee Chat</h2><p>You nailed the invite - now it’s time to optimize the precious chat time you have.</p><p>To start, <strong><a href="https://www.simpleworkapps.com/blog/coffee-chat-questions/">come armed with thoughtful questions</a></strong> tailored to your goals. If seeking career advice, ask about their journey and tips to advance in the field. If exploring a company, inquire about day-to-day roles and how they broke in initially. Good questions get the conversation flowing.</p><p>During the chat, <strong>make listening your main focus</strong>. They’re doing you a favor, so let them share insights without interrupting. Ask follow-up questions to dig deeper into their experiences and perspective.</p><p>Don’t be shy about <strong>asking directly for their advice and feedback</strong> on your goals and plans. For instance, “Based on my background, do you have any suggestions on strengthening my resume?” People enjoy paying experience forward.</p><p><strong>Express genuine interest</strong> in their work by asking what they enjoy most about their current role and exciting initiatives on the horizon. People love discussing their passions.</p><p>When relevant, <strong>briefly share your own relevant experiences and insights</strong> to highlight your capabilities. But avoid monopolizing the conversation.</p><p>Finally, send a <strong>thank you message</strong> recapping key takeaways from the discussion and how you’ll apply their advice. Offer to share helpful resources too.</p><p><a href="https://www.simpleworkapps.com/blog/virtual-coffee-chat/">With active listening, targeted questions, and sincere gratitude, you can build relationships, gather intel, and get guidance to boost your career</a> - one coffee at a time.</p><h2 id="Following-Up-After-the-Coffee-Chat"><a href="#Following-Up-After-the-Coffee-Chat" class="headerlink" title="Following Up After the Coffee Chat"></a>Following Up After the Coffee Chat</h2><p>The coffee chat may be over, but you still have <a href="https://www.simpleworkapps.com/blog/coffee-chat-follow-up-email/">follow-up actions to build the relationship further</a>.</p><p>First, <strong>send a thank you email</strong> within 24 hours recapping the key discussion points and your main takeaways. Express your sincere appreciation for their time and advice. People love being acknowledged.</p><p>Next, <strong>connect on LinkedIn</strong> if you aren’t already connected to keep the professional relationship open. Send a quick note when requesting to connect referencing your enjoyable chat.</p><p>Share any <strong>helpful resources or contacts</strong> promised during the discussion. For example, if they mentioned sending over a link to an interesting article or connecting you with a colleague, follow up to get those valuable nuggets.</p><p>Finally, <strong>occasionally stay in touch</strong> by commenting on their posts, <a href="https://www.simpleworkapps.com/blog/coffee-chat-follow-up-email/">sending interesting articles</a>, or congratulating them on work achievements you notice. But avoid overdoing it - once a month or quarter is plenty.</p><p>The goal is to demonstrate genuine interest in continuing the relationship after the initial chat, without being overly aggressive. With a few simple follow-up touches, you can turn a one-off coffee meeting into an ongoing professional connection.</p><h2 id="Why-You-Should-Ask-for-Coffee-Chats"><a href="#Why-You-Should-Ask-for-Coffee-Chats" class="headerlink" title="Why You Should Ask for Coffee Chats"></a>Why You Should Ask for Coffee Chats</h2><p>Asking colleagues, leaders, and professionals you admire out for coffee may feel awkward, but it offers huge benefits for career development and growth.</p><p>One of the top reasons to request coffee chats is to <strong>expand your professional network</strong>. Meeting new people opens up your connections, which aids in everything from job seeking to industry intel. You never know who might become a mentor.</p><p>Coffee chats also provide an opportunity to <strong>get tailored career advice and insights</strong> from those with more experience. You can ask about their journey, lessons learned, and tips to grow in your role. This kind of wisdom is invaluable.</p><p>Chatting over coffee is also a great way to <strong>learn more about companies or roles you’re interested in pursuing</strong>. Connecting with professionals at your target organizations gives insider perspective you can’t find online.</p><p>Finally, coffee meetings allow you to <strong>make a positive impression on leaders in your field</strong> by showcasing your interpersonal skills. Following up thoughtfully can lead to ongoing mentorship.</p><p>Of course, not every coffee invitation will result in an engaging chat. But putting yourself out there expands your connections, provides guidance, and builds your personal brand. With a thoughtful, concise request and genuine interest in learning from their experiences, coffee chats can positively impact your career.</p><h2 id="Who-to-Ask-for-a-Coffee-Chat"><a href="#Who-to-Ask-for-a-Coffee-Chat" class="headerlink" title="Who to Ask for a Coffee Chat"></a>Who to Ask for a Coffee Chat</h2><p>Coffee chats are a great way to build connections, but who should you reach out to?</p><p>One approach is to identify <strong>respected leaders in your industry</strong> you admire through publications, conferences, <a href="https://www.linkedin.com/">LinkedIn</a>, etc. While they likely won’t become your mentor, most enjoy paying it forward by sharing advice over coffee.</p><p>If interested in a specific company, try connecting with <strong>hiring managers and recruiters</strong> to get the inside scoop on roles and culture. They may even pass your resume along if a good fit arises.</p><p><strong>Alumni from your university</strong> are another option, especially those 3-5 years ahead of you in the same field. Fellow alumni often enjoy helping graduates advance their careers.</p><p>Finally, chat with <strong>more experienced colleagues</strong> in your desired career path. They can explain how they navigated new roles and share tips to fast track your growth.</p><p>The best contacts are those with wisdom to share who you resonate with. Avoid asking CEOs or celebs out of the blue, but do take a chance requesting time from professionals one step ahead of where you want to be. A warm outreach can spark insightful discussions and valuable connections.</p><h2 id="Key-Takeaways"><a href="#Key-Takeaways" class="headerlink" title="Key Takeaways"></a>Key Takeaways</h2><p>Requesting and conducting coffee chats takes preparation and follow through, but can significantly benefit your career.</p><p>Here are the key takeaways to ensure your coffee meetings are successful:</p><ul><li><strong>Do your research beforehand</strong> to personalize requests and conversations. Study their background so you can ask informed, relevant questions.</li><li><strong><a href="https://www.simpleworkapps.com/blog/coffee-chat-email/">Keep invitation emails concise and direct</a></strong> with just 2-3 paragraphs. Introduce yourself, explain common interests, and propose meeting over coffee.</li><li>Always <strong>suggest specific dates&#x2F;times</strong> that work for you versus saying “let me know when you’re free!” Offer options if possible.</li><li><strong>Follow up politely</strong> if they don’t respond within a week. But accept the no gracefully if they decline or ignore your note.</li><li>In the chat, <strong>listen more than speak</strong> and come prepared with thoughtful questions tailored to your goals. Don’t just pitch yourself.</li><li><strong>Express genuine interest</strong> in their experiences and company. Ask what they enjoy most about their work.</li><li><strong><a href="https://www.simpleworkapps.com/blog/coffee-chat-thank-you-email/">Send a prompt thank you note</a></strong> recapping the discussion. Offer to connect on <a href="https://www.linkedin.com/">LinkedIn</a> and share helpful resources mentioned.</li><li><strong>Occasionally stay in touch</strong> by commenting on updates, sending articles, or congratulating achievements. But avoid pestering them.</li></ul><p>While not every request will result in a meeting, coffee chats are invaluable for expanding your network, gaining wisdom, and making great impressions. With a focused, thoughtful approach, enjoy the career benefits productive coffee meetings offer!</p>]]></content>
    
    
    <categories>
      
      <category>英文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Learn from Bloomberg</title>
    <link href="/%E8%B7%9F%E7%9D%80%E5%BD%AD%E5%8D%9A%E7%A4%BE%E5%AD%A6%E8%8B%B1%E8%AF%AD/"/>
    <url>/%E8%B7%9F%E7%9D%80%E5%BD%AD%E5%8D%9A%E7%A4%BE%E5%AD%A6%E8%8B%B1%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://www.bloomberg.com/news/articles/2025-02-10/chinese-investors-drive-hong-kong-rally-with-19-billion-inflow">https://www.bloomberg.com/news/articles/2025-02-10/chinese-investors-drive-hong-kong-rally-with-19-billion-inflow</a></p><h4 id="Chinese-Investors-Drive-Hong-Kong-Rally-止跌回升-With-19-Billion-Inflow-流入"><a href="#Chinese-Investors-Drive-Hong-Kong-Rally-止跌回升-With-19-Billion-Inflow-流入" class="headerlink" title="Chinese Investors Drive Hong Kong Rally(止跌回升) With $19 Billion Inflow(流入)"></a>Chinese Investors Drive Hong Kong Rally(止跌回升) With $19 Billion Inflow(流入)</h4><p><strong>中国投资者涌入190亿美元，推动香港股市上涨</strong></p><p>​       Chinese investors are helping to drive a bull run in Hong Kong shares, plowing(<strong>推动</strong>) almost HK$150 billion ($19.3 billion) into the <u>financial hub</u>(<strong>金融中心</strong>) this year, more than seven times the amount they added during the same period in 2024. That’s despite an earlier Chinese New Year holiday reducing the number of trading days this year.</p><p>​     中国投资者正在帮助推动香港股市的牛市行情，今年已向这个金融中心投入近1500亿港元（193亿美元），是2024年同期投入金额的七倍多。尽管今年春节假期提前减少了交易天数，但这种情况依然存在。</p><p>​     <u>Turnover</u>(<strong>成交额</strong>) in Hong Kong via the exchange links accounted for nearly half the total on Monday with another HK$16.5 billion of purchases, the most since early December. Mainland investors have been ardent(热衷的) buyers of Tencent Holdings Ltd., taking their stake to around 11.4% of shares outstanding, and of Xiaomi Corp, of which they now own 16.2%.</p><p>​     通过交易所互联互通机制流入香港的成交额周一几乎占总成交额的一半，另有165亿港元的买入，为12月初以来最多。中国内地投资者一直是腾讯控股有限公司的热情买家，他们的持股比例已增至约占已发行股份的11.4%；同时他们也是小米集团的买家，目前持有该公司16.2%的股份。</p><p>​     Optimism over DeepSeek, a Chinese artificial intelligence startup, has catapulted(<strong>弹射上涨</strong>) the Hang Seng Tech Index into a <u>bull market (</u><strong>牛市</strong>)last week. In contrast, <u>onshore investors</u>(<strong>境内投资者</strong>) have been more hesitant to <u>bid up</u>(<strong>抬高出价</strong>) stocks on their side of the border, with the CSI 300 Index down nearly 1% for the year.</p><p>对中国人工智能初创公司deepseek的乐观情绪推动恒生科技指数上周进入牛市。 相比之下，中国内地的投资者对其境内的股票出价更为犹豫，沪深300指数今年下跌近1%。</p><h4 id="单词"><a href="#单词" class="headerlink" title="单词"></a><strong>单词</strong></h4><ul><li>rally v&#x2F;n 止跌回升</li></ul><p> 例句：The company’s shares had rallied slightly by the close of trading. 这家公司的股票价格在收盘前略有回升。</p><ul><li>inflow n (资金、人的) 流入，涌入</li></ul><p>例句：The Swiss wanted to discourage an inflow of foreign money 瑞士想要阻止外资的流入</p><ul><li>bull market n 牛市</li></ul><p>例句：The bull market will end — but when is the question 牛市会结束，问题是何时结束</p><ul><li>onshore investor n 境内投资者</li><li>offshore investor n 境外投资者</li><li>bid up v 抬价；竞高出价</li></ul><p>例句：The price of that painting was bid up 那幅画的价格被抬起来了。</p>]]></content>
    
    
    <categories>
      
      <category>英文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Chinese New Year English</title>
    <link href="/%E5%86%9C%E5%8E%86%E6%96%B0%E5%B9%B4%E8%8B%B1%E8%AF%AD/"/>
    <url>/%E5%86%9C%E5%8E%86%E6%96%B0%E5%B9%B4%E8%8B%B1%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<p><strong>Spring Festival | 春节 | [sprɪŋ ˈfɛs.tɪ.vəl]</strong></p><ul><li><strong>例句</strong>: The Spring Festival is the most important traditional holiday in China.<br>（春节是中国最重要的传统节日。）</li></ul><p><strong>Lunar New Year | 农历新年 | [ˈluː.nər nuː jɪr]</strong></p><ul><li><strong>例句</strong>: Lunar New Year is celebrated in many Asian countries, not just in China.<br>（农历新年在许多亚洲国家庆祝，不仅仅在中国。）</li></ul><p><strong>Red Envelope | 红包 | [rɛd ˈɛn.və.loʊp]</strong></p><ul><li><strong>例句</strong>: Giving red envelopes with money inside is a common tradition during Chinese New Year.<br>（春节时发红包是一个常见的传统。）</li></ul><p><strong>Fireworks | 烟花 | [ˈfaɪər.wɜːrks]</strong></p><ul><li><strong>例句</strong>: Many cities have large fireworks displays to celebrate the New Year.<br>（许多城市会燃放烟花庆祝新年。）</li></ul><p><strong>Lion Dance | 舞狮 | [laɪən dæns]</strong></p><ul><li><strong>例句</strong>: The lion dance is performed to bring good luck and drive away evil spirits.<br>（舞狮表演是为了带来好运并驱赶邪灵。）</li></ul><p><strong>Reunion Dinner | 团圆饭 | [rɪˈjuː.ni.ən ˈdɪnər]</strong></p><ul><li><strong>例句</strong>: Families gather together for a reunion dinner on New Year’s Eve.<br>（除夕夜家人会聚在一起吃团圆饭。）</li></ul><p><strong>Spring Couplets | 春联 | [sprɪŋ ˈkʌp.ləts]</strong></p><ul><li><strong>例句</strong>: People paste spring couplets on their doors to welcome the New Year.<br>（人们把春联贴在门上迎接新年。）</li></ul><p><strong>Chinese Zodiac | 十二生肖 | [ˈʧaɪ.niz ˈzoʊ.di.æk]</strong></p><ul><li><strong>例句</strong>: Each year is associated with one of the 12 animals in the Chinese zodiac.<br>（每一年都与十二生肖中的一个动物相关联。）</li></ul><p><strong>Good Luck | 好运 | [ɡʊd lʌk]</strong></p><ul><li><strong>例句</strong>: People exchange greetings to wish each other good luck for the New Year.<br>（人们互相问候以祝愿彼此在新的一年里好运。）</li></ul><p><strong>Lantern Festival | 元宵节 | [ˈlæn.tərn ˈfɛs.tɪ.vəl]</strong></p><ul><li><strong>例句</strong>: The Lantern Festival marks the end of Chinese New Year celebrations.<br>（元宵节标志着春节庆祝活动的结束。）</li></ul><p><strong>Decorations | 装饰品 | [ˌdɛk.əˈreɪ.ʃənz]</strong></p><ul><li><strong>例句</strong>: Red decorations can be seen everywhere during Chinese New Year.<br>（春节期间到处都可以看到红色的装饰品。）</li></ul><p><strong>Prosperity | 繁荣&#x2F;兴旺 | [prɑːˈspɛr.ɪ.ti]</strong></p><ul><li><strong>例句</strong>: The color red symbolizes happiness and prosperity in Chinese culture.<br>（红色在中国文化中象征着幸福和繁荣。）</li></ul><p><strong>New Year’s Resolution | 新年愿望 | [nuː jɪrz ˌrɛz.əˈluː.ʃən]</strong></p><ul><li><strong>例句</strong>: Many people make New Year’s resolutions to improve their lives.<br>（许多人制定新年愿望来改善生活。）</li></ul><p><strong>Traditional Clothes | 传统服装 | [trəˈdɪʃ.ən.əl kloʊz]</strong></p><ul><li><strong>例句</strong>: During Chinese New Year, people often wear traditional clothes like cheongsams.<br>（春节期间，人们常穿传统服装，如旗袍。）</li></ul><p><strong>Blessings | 祝福 | [ˈblɛs.ɪŋz]</strong></p><ul><li><strong>例句</strong>: Everyone shares blessings for a happy and prosperous year ahead.<br>（每个人都分享对新一年幸福与繁荣的祝福。）</li></ul>]]></content>
    
    
    <categories>
      
      <category>英文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Learn from House of Cards</title>
    <link href="/%E8%B7%9F%E7%9D%80%E7%BA%B8%E7%89%8C%E5%B1%8B%E5%AD%A6%E8%8B%B1%E6%96%87/"/>
    <url>/%E8%B7%9F%E7%9D%80%E7%BA%B8%E7%89%8C%E5%B1%8B%E5%AD%A6%E8%8B%B1%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h3 id="1-词汇-Vocabulary"><a href="#1-词汇-Vocabulary" class="headerlink" title="1. 词汇 (Vocabulary)"></a>1. <strong>词汇 (Vocabulary)</strong></h3><table><thead><tr><th><strong>英语词汇</strong></th><th><strong>中文含义</strong></th><th><strong>发音</strong></th><th><strong>例句</strong></th></tr></thead><tbody><tr><td>Manipulation</td><td>操纵</td><td>&#x2F;ˌmænɪpjʊˈleɪʃn&#x2F;</td><td>Frank is a master of political manipulation. （弗兰克是操纵政治的高手。）</td></tr><tr><td>Leverage</td><td>杠杆；影响力</td><td>&#x2F;ˈlevərɪdʒ&#x2F;</td><td>He used his connections as leverage to get what he wanted.</td></tr><tr><td>Betrayal</td><td>背叛</td><td>&#x2F;bɪˈtreɪəl&#x2F;</td><td>Betrayal is a recurring theme in the series.</td></tr><tr><td>Accountability</td><td>问责；责任</td><td>&#x2F;əˌkaʊntəˈbɪləti&#x2F;</td><td>Politicians must uphold accountability to the public.</td></tr><tr><td>Ruthless</td><td>无情的；冷酷的</td><td>&#x2F;ˈruːθləs&#x2F;</td><td>Frank’s ruthless tactics shock everyone.</td></tr><tr><td>Diplomacy</td><td>外交</td><td>&#x2F;dɪˈpləʊməsi&#x2F;</td><td>Diplomacy often requires strategic thinking.</td></tr><tr><td>Constituency</td><td>选区；选民</td><td>&#x2F;kənˈstɪtʃuənsi&#x2F;</td><td>Frank worked hard to gain the trust of his constituency.</td></tr><tr><td>Scandal</td><td>丑闻</td><td>&#x2F;ˈskændl&#x2F;</td><td>The media exposed a huge scandal involving the senator.</td></tr></tbody></table><h3 id="2-经典台词"><a href="#2-经典台词" class="headerlink" title="2. 经典台词"></a>2. 经典台词</h3><p><strong>“Democracy is so overrated.”</strong></p><p>民主被高估了。</p><p><strong>“There’s no better way to overpower a trickle of doubt than with a flood of naked truth.”</strong></p><p>压制一丝怀疑最好的方法就是用赤裸裸的真相淹没它。</p><p><strong>“I have no patience for useless things.”</strong></p><p>我对无用之事毫无耐心。</p><p><strong>“Power is a lot like real estate. It’s all about location, location, location.”</strong></p><p>权力就像房地产，一切都关乎地段、地段、地段。</p><p><strong>“Hunt or be hunted.”</strong></p><p>不是猎人就是猎物。</p><p>“**I never make such big decisions so long after sunset and so far from dawn.”   **</p><p>我从不在日落之后、黎明之前做出重大的决定。</p>]]></content>
    
    
    <categories>
      
      <category>英文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Technical English</title>
    <link href="/%E5%90%8E%E7%AB%AF%E8%8B%B1%E8%AF%AD%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/"/>
    <url>/%E5%90%8E%E7%AB%AF%E8%8B%B1%E8%AF%AD%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<p>本文梳理了后端常见的技术术语，包括性能优化、JVM、数据库等维度</p><span id="more"></span><h4 id="专业词汇"><a href="#专业词汇" class="headerlink" title="专业词汇"></a>专业词汇</h4><hr><table><thead><tr><th>中文</th><th>英文</th><th>分类</th><th>发音</th></tr></thead><tbody><tr><td>吞吐量</td><td>throughput</td><td>performance</td><td><em>&#x2F;<em>ˈθruːpʊt</em>&#x2F;</em></td></tr><tr><td>并发</td><td>Concurrency</td><td>performance</td><td></td></tr><tr><td>最大</td><td>maximum</td><td>performance</td><td><em>&#x2F;<em>ˈmæksɪməm</em>&#x2F;</em></td></tr><tr><td>最小</td><td>minimum</td><td>performance</td><td><em>&#x2F;<em>ˈmɪnɪməm</em>&#x2F;</em></td></tr><tr><td>异步</td><td>asynchronization</td><td></td><td></td></tr><tr><td>同步</td><td>synchronization</td><td></td><td></td></tr><tr><td>线程池</td><td>Thread Pool</td><td></td><td></td></tr><tr><td>边界</td><td><strong>boundaries</strong></td><td>algorithm</td><td><em>&#x2F;<em>ˈbaʊndriz</em>&#x2F;</em></td></tr><tr><td>递归</td><td><strong>recursive</strong></td><td>algorithm</td><td><em>&#x2F;<em>rɪˈkɜːrsɪv</em>&#x2F;</em></td></tr><tr><td>二分搜索</td><td>binary search</td><td>algorithm</td><td></td></tr><tr><td>二叉树</td><td>binary tree</td><td>algorithm</td><td></td></tr><tr><td>回溯</td><td>Backtracking</td><td>algorithm</td><td></td></tr><tr><td>排列</td><td><strong>Permutation</strong></td><td>algorithm</td><td><em>&#x2F;<em>ˌpɜːrmjuˈteɪʃ(ə)n</em>&#x2F;</em></td></tr><tr><td>括号</td><td><strong>parentheses</strong></td><td>algorithm</td><td>&#x2F;pəˈrenθəsiːz&#x2F;</td></tr><tr><td>轮询</td><td>poll</td><td></td><td></td></tr><tr><td>分代</td><td>generations</td><td>JVM</td><td></td></tr><tr><td>老年代</td><td><em>tenured generation</em></td><td>JVM</td><td></td></tr><tr><td>垃圾回收</td><td>Garbage collection</td><td>JVM</td><td></td></tr><tr><td>年轻代</td><td><em>young generation</em></td><td>JVM</td><td></td></tr><tr><td>eden区</td><td>eden space</td><td>JVM</td><td></td></tr><tr><td>survivor 区</td><td>survivor space</td><td>JVM</td><td></td></tr><tr><td>垃圾回收停顿时间</td><td><strong>Garbage Collection Pause Time</strong></td><td>JVM</td><td></td></tr><tr><td>停顿时间长</td><td>Long Pause Time</td><td></td><td></td></tr><tr><td>内存碎片</td><td>Memory <strong>Fragmentation</strong></td><td></td><td>&#x2F;ˈmɛməri ˌfræɡmɛnˈteɪʃən&#x2F;</td></tr><tr><td>频繁GC</td><td>Frequent FullGC</td><td></td><td></td></tr><tr><td>吞吐量下降</td><td>Throughput Drop</td><td></td><td></td></tr><tr><td>GC过多</td><td><strong>Excessive</strong> GC</td><td></td><td></td></tr><tr><td>晋升失败</td><td>Promotion Failure</td><td></td><td></td></tr><tr><td>老年代满了</td><td>Old Generation Full</td><td></td><td></td></tr><tr><td>元空间溢出</td><td>Metaspace Overflow</td><td></td><td></td></tr><tr><td>堆内存不足</td><td>Heap Memory Insufficient</td><td></td><td>&#x2F;hiːp ˈmɛməri ˌɪnsəˈfɪʃənt&#x2F;</td></tr><tr><td>GC时间比例</td><td>GCTimeRatio</td><td>JVM</td><td></td></tr><tr><td>串行垃圾回收器</td><td>Serial Garbage Collector</td><td>JVM</td><td></td></tr><tr><td>并行垃圾回收器</td><td>Parallel Garbage Collector</td><td>JVM</td><td></td></tr><tr><td>避免内存泄漏</td><td>Avoid Memory Leaks</td><td>JVM</td><td></td></tr><tr><td>调整堆大小</td><td>Adjust Heap Size</td><td>JVM</td><td></td></tr><tr><td>调整垃圾回收器参数</td><td>Tuning Garbage Collector Parameters</td><td>JVM</td><td></td></tr><tr><td>减少对象创建</td><td>Reduce Object Creation</td><td>JVM</td><td></td></tr><tr><td>优化内存分配</td><td>Optimize Memory Allocation</td><td>JVM</td><td></td></tr><tr><td>增加元空间大小</td><td>Increase Metaspace Size</td><td>JVM</td><td></td></tr><tr><td>命令行</td><td>command-line</td><td></td><td></td></tr><tr><td>事务</td><td>Transactions</td><td>Mysql</td><td></td></tr><tr><td>一致性</td><td>Consistency</td><td>Mysql</td><td><em>&#x2F;<em>kənˈsɪstənsi</em>&#x2F;</em></td></tr><tr><td>隔离级别</td><td>Isolation level</td><td>Mysql</td><td></td></tr><tr><td>脏读</td><td>dirty-read</td><td>Mysql</td><td></td></tr><tr><td>不可重复读</td><td>Non-repeatable-read</td><td>Mysql</td><td></td></tr><tr><td>幻读</td><td>phantom-read</td><td>Mysql</td><td><em>&#x2F;<em>ˈfæntəm</em>&#x2F;</em></td></tr><tr><td>主键索引</td><td>primary-index</td><td>Mysql</td><td></td></tr><tr><td>唯一索引</td><td>unique-index</td><td>Mysql</td><td></td></tr><tr><td>普通索引</td><td>Secondary-index</td><td>Mysql</td><td></td></tr><tr><td>联合索引</td><td>Composite-index</td><td>Mysql</td><td><em>&#x2F;<em>kəmˈpɑːzət</em>&#x2F;</em></td></tr><tr><td>连续</td><td><strong>consecutive</strong></td><td>algorithm</td><td><em>&#x2F;<em>kənˈsekjətɪv</em>&#x2F;</em></td></tr><tr><td>相邻的</td><td><strong>adjacent</strong></td><td>algorithm</td><td><em>&#x2F;<em>əˈdʒeɪs(ə)nt</em>&#x2F;</em></td></tr><tr><td>回文结构</td><td><strong>palindromic</strong></td><td>algorithm</td><td><em>&#x2F;<em>ˌpælɪnˈdrɒmɪk</em>&#x2F;</em></td></tr><tr><td>重复</td><td><strong>duplicates</strong></td><td>algorithm</td><td></td></tr><tr><td>填充</td><td>populate</td><td>algorithm</td><td></td></tr><tr><td>单调的</td><td><strong>monotonic</strong></td><td>algorithm</td><td><em>&#x2F;<em>ˌmɑːnəˈtɑːnɪk</em>&#x2F;</em></td></tr><tr><td>限流</td><td><strong>throttling</strong></td><td></td><td>&#x2F;ˈθrɒtəlɪŋ&#x2F;</td></tr><tr><td>断路器</td><td><strong>Circuit Breaker</strong></td><td>system design</td><td>&#x2F;ˈsɜːrkɪtˌbreɪkər&#x2F;</td></tr><tr><td>降级处理</td><td>Degrade Handling</td><td>system design</td><td>&#x2F;dɪˈɡreɪd ˈhændlɪŋ&#x2F;</td></tr><tr><td>自动故障恢复</td><td>Automatic Recovery</td><td>system design</td><td>&#x2F;ˌɔːtəˈmætɪk rɪˈkʌvəri&#x2F;</td></tr><tr><td>网络延迟</td><td>Network Latency</td><td></td><td></td></tr><tr><td>延迟抖动</td><td>Latency <strong>Jitter</strong></td><td></td><td>&#x2F;ˈleɪtənsi ˈʤɪtər&#x2F;</td></tr><tr><td>数据包丢失</td><td>Packet Loss</td><td></td><td></td></tr><tr><td>带宽优化</td><td>Bandwidth Optimization</td><td></td><td></td></tr><tr><td>连接池</td><td>Connection Pooling</td><td></td><td></td></tr><tr><td>线程安全</td><td>Thread Safety</td><td></td><td></td></tr><tr><td>死锁</td><td>Deadlock</td><td></td><td></td></tr><tr><td>自旋锁</td><td><strong>Spinlock</strong></td><td></td><td></td></tr><tr><td>乐观锁</td><td>Optimistic Lock</td><td></td><td></td></tr><tr><td>分段锁</td><td>Segment Lock</td><td></td><td></td></tr><tr><td>偏向锁</td><td><strong>Biased</strong> Lock</td><td></td><td>&#x2F;ˈbaɪəst lɒk&#x2F;</td></tr><tr><td>无锁编程</td><td>Lock-free Programming</td><td></td><td></td></tr><tr><td>乐观并发控制</td><td>Optimistic Concurrency Control</td><td></td><td></td></tr><tr><td>原子操作</td><td>Atomic Operation</td><td></td><td></td></tr><tr><td>生产-消费者模型</td><td>Producer-Consumer Model</td><td></td><td></td></tr><tr><td>发布-订阅模型</td><td>Publish-Subscribe Model</td><td></td><td></td></tr><tr><td>线程本地存储</td><td>Thread-local Storage</td><td></td><td></td></tr><tr><td>Java线程池框架</td><td>Java Thread Pool Framework</td><td></td><td></td></tr><tr><td>并发集合</td><td>Concurrent Collections</td><td></td><td></td></tr><tr><td>并发队列</td><td>Concurrent Queue</td><td></td><td></td></tr><tr><td>原子变量</td><td>Atomic Variables</td><td></td><td>&#x2F;əˈtɒmɪk ˈvɛriəbəlz&#x2F;</td></tr><tr><td>CompletableFuture类</td><td>CompletableFuture Class</td><td></td><td>&#x2F;kəmˈpliːtəbl ˈfjuːʧər klɑːs&#x2F;</td></tr><tr><td>线程复用</td><td>Thread Reuse</td><td></td><td></td></tr><tr><td>非阻塞队列</td><td>Non-blocking Queue</td><td></td><td></td></tr><tr><td>分布式并发控制</td><td>Distributed Concurrency Control</td><td></td><td></td></tr><tr><td>降低锁争用</td><td>Reduce Lock Contention</td><td></td><td></td></tr><tr><td>延迟加载</td><td>Lazy Loading</td><td></td><td></td></tr><tr><td>火焰图</td><td>Flame Graph</td><td></td><td></td></tr><tr><td>日志分析</td><td>Log Analysis</td><td></td><td></td></tr><tr><td>流量削峰</td><td>Peak Shaving</td><td></td><td>&#x2F;piːk ˈʃeɪvɪŋ&#x2F;</td></tr><tr><td>滑动窗口算法</td><td>Sliding Window Algorithm</td><td></td><td>&#x2F;ˈslaɪdɪŋ ˈwɪndoʊ ˈælɡərɪðəm&#x2F;</td></tr><tr><td>零拷贝</td><td>Zero-copy</td><td></td><td></td></tr><tr><td>批处理</td><td>Batch Processing</td><td></td><td></td></tr><tr><td>事件驱动架构</td><td>Event-driven Architecture</td><td></td><td></td></tr><tr><td>后台任务调度</td><td>Background Task Scheduling</td><td></td><td></td></tr><tr><td>线程竞争</td><td>Thread Contention</td><td></td><td>&#x2F;θrɛd kənˈtɛnʃən&#x2F;</td></tr><tr><td>可用性</td><td>Availability</td><td></td><td>&#x2F;əˌveɪləˈbɪlɪti&#x2F;</td></tr><tr><td>容错机制</td><td>Fault Tolerance</td><td></td><td>&#x2F;fɔːlt ˈtɒlərəns&#x2F;</td></tr><tr><td>瓶颈</td><td>Bottleneck</td><td></td><td>&#x2F;ˈbɒtlˌnɛk&#x2F;</td></tr><tr><td>算法</td><td>Algorithm</td><td></td><td></td></tr><tr><td>时间复杂度</td><td>Time Complexity</td><td></td><td></td></tr><tr><td>空间复杂度</td><td>Space Complexity</td><td></td><td></td></tr><tr><td>最坏情况</td><td>Worst-case</td><td></td><td></td></tr><tr><td>最好情况</td><td>Best-case</td><td></td><td></td></tr><tr><td>测试用例</td><td>Test Case</td><td></td><td></td></tr><tr><td>N*M</td><td>N times M</td><td></td><td></td></tr><tr><td>N的平方</td><td>N squared</td><td></td><td></td></tr><tr><td>O(N)</td><td>big-O</td><td></td><td></td></tr><tr><td>边界情况</td><td>Edge Case</td><td></td><td></td></tr><tr><td>极端情况</td><td>Corner Case</td><td></td><td></td></tr><tr><td>遍历数组</td><td>Loop Through the Array</td><td></td><td></td></tr><tr><td>暴力破解</td><td>Brute Force</td><td></td><td></td></tr><tr><td>排列</td><td>Permutation</td><td></td><td></td></tr><tr><td>组合</td><td>Combination</td><td></td><td></td></tr><tr><td>回文的</td><td>Palindromic</td><td></td><td></td></tr><tr><td>括号</td><td>Parentheses</td><td></td><td></td></tr><tr><td>重复</td><td>Duplicates</td><td></td><td></td></tr><tr><td>旋转</td><td>Rotate</td><td></td><td></td></tr><tr><td>区间</td><td>Intervals</td><td></td><td></td></tr><tr><td>螺旋的</td><td>Spiral</td><td></td><td></td></tr><tr><td>对称的</td><td>Symmetric</td><td></td><td></td></tr><tr><td>变平</td><td>Flatten</td><td></td><td></td></tr><tr><td>三角形</td><td>Triangle</td><td></td><td></td></tr><tr><td>相交点</td><td>Intersection</td><td></td><td></td></tr><tr><td>峰值元素</td><td>Peak Element</td><td></td><td></td></tr><tr><td>连续的</td><td>Consecutive</td><td></td><td></td></tr><tr><td>滑动窗口</td><td>Sliding Window</td><td></td><td></td></tr><tr><td>想出</td><td>Come up with</td><td></td><td></td></tr><tr><td>逆序</td><td>Reverse Order</td><td></td><td></td></tr><tr><td>非负的</td><td>Non-negative</td><td></td><td></td></tr><tr><td>小写字母</td><td>Lowercase</td><td></td><td></td></tr><tr><td>唯一的</td><td>Distinct</td><td></td><td></td></tr><tr><td>水平扩展</td><td>Horizontal scaling</td><td></td><td></td></tr><tr><td>垂直扩展</td><td>Vertical scaling</td><td></td><td></td></tr><tr><td>重试机制</td><td>Retry mechanism</td><td></td><td></td></tr><tr><td>CPU利用率</td><td><strong>CPU utilization</strong></td><td></td><td></td></tr><tr><td>高CPU负载</td><td>High CPU load</td><td></td><td></td></tr><tr><td>容器化</td><td>Containerization</td><td></td><td></td></tr><tr><td>容器编排</td><td><strong>Container orchestration</strong></td><td></td><td></td></tr><tr><td>回退策略</td><td>Backoff strategy</td><td></td><td></td></tr><tr><td>分区容错性</td><td>Partition tolerance</td><td></td><td></td></tr><tr><td>强一致性</td><td><strong>Strong consistency</strong></td><td></td><td></td></tr><tr><td>最终一致性</td><td>Eventual consistency</td><td></td><td></td></tr></tbody></table><h4 id="日常单词学习"><a href="#日常单词学习" class="headerlink" title="日常单词学习"></a>日常单词学习</h4><p><em><strong>asynchronization n 异步化</strong></em></p><p><strong>English:</strong> Implementing <strong>asynchronization</strong> in our backend architecture significantly reduced response times.<br><strong>中文：</strong> 在后端架构中引入<strong>异步化</strong>显著降低了响应时间。</p><p><em><strong>concurrency n 并发度</strong></em></p><p><strong>English:</strong> Managing <strong>concurrency</strong> effectively is crucial in high-traffic web applications to avoid data inconsistencies.<br><strong>中文：</strong> 在高流量的网络应用程序中，有效地管理<strong>并发</strong>对于避免数据不一致至关重要。</p><p><em><strong>bottleneck n 瓶颈</strong></em></p><p><strong>English:</strong> When user traffic skyrocketed, the database became a major <strong>bottleneck</strong>.<br><strong>中文：</strong> 当用户流量飙升时，数据库成了主要的<strong>瓶颈</strong>。</p><p><em><strong>Circuit Breaker  n 熔断机制</strong></em></p><p><strong>English:</strong> Utilizing a <strong>Circuit Breaker</strong> pattern in microservices can prevent cascading failures and enhance system resilience.<br><strong>中文：</strong> 在微服务中使用 <strong>熔断机制</strong>可以防止级联故障并提高系统的弹性。</p><p><em><strong>thread safety  n 线程安全</strong></em></p><p><strong>English:</strong> Ensuring <strong>thread safety</strong> is essential for maintaining data integrity in multi-threaded applications.<br><strong>中文：</strong> 确保<strong>线程安全</strong>对于在多线程应用程序中保持数据完整性至关重要。</p><p><em><strong>Lazy Loading n 懒加载</strong></em></p><p><strong>English:</strong> Many modern websites use <strong>Lazy Loading</strong> to improve page load times by deferring the loading of images or resources until they are needed.<br><strong>中文：</strong> 许多现代网站通过<strong>延迟加载</strong>来提升页面加载速度，只有在需要时才加载图片或资源。</p><p><em><strong>Peak Shaving n 流量削峰</strong></em></p><p><strong>English:</strong> By implementing <strong>Peak Shaving</strong> strategies, the platform can evenly distribute user load and prevent system overload during traffic spikes.<br><strong>中文：</strong> 通过实施<strong>削峰</strong>策略，平台可以均衡分配用户负载，防止在流量高峰期出现系统过载。</p><p><em><strong>Background Task Scheduling n 后台任务调度</strong></em></p><p>**English:**Implementing <strong>Background Task Scheduling</strong> helps automate routine processes and optimize system performance.</p><p><strong>中文：</strong>使用<strong>后台任务调度</strong>可以自动化常规流程并优化系统性能。</p><p><em><strong>hatch v  孵化</strong></em> </p><p> <strong>English:</strong> Entrepreneurs strive to <strong>hatch</strong> disruptive internet startups </p><p><strong>中文:</strong> 企业家们努力<strong>孵化</strong>颠覆性的互联网初创企业。</p><p><em><strong>radical adj 激进的；根本的</strong></em></p><p><strong>English:</strong> Tech innovators make <strong>radical</strong> changes to the internet ecosystem.</p><p><strong>中文：</strong> 科技创新者对互联网生态系统进行<strong>激进</strong>的变革。</p><p><em><strong>gloomy adj 黯淡的；沮丧的</strong></em></p><p><strong>English:</strong> The tech startup’s outlook seemed <strong>gloomy</strong> after its funding fell through.<br><strong>中文：</strong> 这家科技初创企业的前景在融资失败后显得<strong>暗淡</strong>。</p><p><em><strong>consolidate v  巩固；整合</strong></em></p><p><strong>English:</strong> Online retailers aim to <strong>consolidate</strong> multiple payment gateways to enhance user experience.<br><strong>中文：</strong> 在线零售商努力整合多种支付网关，以提升用户体验。</p><p><em><strong>blur v 使…模糊不清</strong></em></p><p><strong>English:</strong> As virtual reality evolves, it continues to <strong>blur</strong> the boundaries between the physical and digital worlds.<br><strong>中文：</strong> 随着虚拟现实的发展，它不断<strong>模糊</strong>现实世界与数字世界之间的界限。</p><p><em><strong>obsolete adj 废弃的；过时的</strong></em></p><p><strong>English:</strong> Many once-popular technologies quickly become <strong>obsolete</strong> in today’s fast-paced internet industry.<br><strong>中文：</strong> 在当今节奏飞快的互联网行业，许多曾经流行的技术很快就会变得<strong>过时</strong>。</p><p><em><strong>tactic n 策略</strong></em></p><p><strong>English:</strong> In the fiercely competitive internet market, adopting a data-driven marketing <strong>tactic</strong> is crucial.<br><strong>中文：</strong> 在竞争激烈的互联网市场中，采用数据驱动的营销<strong>策略</strong>至关重要。</p>]]></content>
    
    
    <categories>
      
      <category>英文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法-bloomfilter数据结构技术总结</title>
    <link href="/14-bloomfilter%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <url>/14-bloomfilter%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>bloomfilter是一种节省空间的概率数据结构，用于测试数据元素是否在一个集合中.</p><span id="more"></span><p><em>前言：bloomfilter是一种节省空间的概率数据结构，用于测试数据元素是否在一个集合中。核心是通过一个位数组来存储经过一组hash计算之后的值，通过判断位数组位置是否为1来判断元素是否存在。本质上是通过<strong>计算换空间</strong>的一种算法。类似的数据结构还有Trie前缀树，它是通过计算公共前缀来节省空间的。</em></p><h3 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h3><ol><li>大数据Hbase的rowkey是否存在某个数据块、API网关应用是否存在、邮件中某个用户是否在黑名单等</li><li>解决缓存穿透问题，用于提前过滤掉无用的查询或者调用，减轻数据库的压力。</li></ol><h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><p><strong>解决什么问题</strong>：利用hash函数和位存储来解决判断是否一个元素存在的问题，因为可能会有hash冲突，所以当返回结果是true时，元素不一定会存在，但返回false，元素一定不存在。</p><p><strong>核心数据结构</strong>：一组hash函数和位存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BloomFilter</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> BitSet bitSet;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hashFunctions;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BloomFilter</span><span class="hljs-params">(<span class="hljs-type">int</span> size, <span class="hljs-type">int</span> hashFunctions)</span> &#123;<br>        <span class="hljs-built_in">this</span>.size = size;<br>        <span class="hljs-built_in">this</span>.hashFunctions = hashFunctions;<br>        <span class="hljs-built_in">this</span>.bitSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BitSet</span>(size);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; hashFunctions; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hashFunction(i, value);<br>            bitSet.set(hash % size);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; hashFunctions; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hashFunction(i, value);<br>            <span class="hljs-keyword">if</span> (!bitSet.get(hash % size)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="Java数据结构BitSet实现"><a href="#Java数据结构BitSet实现" class="headerlink" title="Java数据结构BitSet实现"></a>Java数据结构BitSet实现</h3><h4 id="1-构建一个BitSet"><a href="#1-构建一个BitSet" class="headerlink" title="1.构建一个BitSet"></a>1.构建一个BitSet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化-&gt; nbits为容量，</span><br><span class="hljs-type">long</span>[] words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[wordIndex(nbits-<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 存储</span><br><br><span class="hljs-comment">// 相当于 N/64,这里用移位操作,向右移6位，也就是除以2^6</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wordIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> bitIndex)</span> &#123;<br>   <span class="hljs-keyword">return</span> bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD; <span class="hljs-comment">// ADDRESS_BITS_PER_WORD为6</span><br>&#125;<br></code></pre></td></tr></table></figure><p>BitSet数据结构：<strong>容量N、****Long[]</strong>(一个Long是8个Byte，一个Byte是8个bit，那么就是64个bit)</p><h4 id="2-添加元素"><a href="#2-添加元素" class="headerlink" title="2. 添加元素"></a>2. 添加元素</h4><p>假设我们添加一个Key，经过hash计算后得到的值为7，那么意味着第7个位置为0，那么对应到Long的值为128，那么与此处之前的Long值进行或运算，意味着添加成功。</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/p4d89evpLkfxNHuicvxq2vjwlo5ibC4SO78RZwERBNibnI8m9AJ2gckF9YIVh6ibT24xGzN7Yq7aWAcWiaN6na0h68g/640?wx_fmt=jpeg&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><em>BitSet添加一个元素的过程</em></p><p><strong>开源的实现</strong></p><p>Guava: <a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/hash/BloomFilter.java">https://github.com/google/guava/blob/master/guava/src/com/google/common/hash/BloomFilter.java</a></p><p><strong>优势与不足</strong></p><p>优势：节省内存，通常可以降低70%左右的内存</p><p>不足：有一定的误判率、不可删除元素</p>]]></content>
    
    
    <categories>
      
      <category>后端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI技术-李飞飞采访实录</title>
    <link href="/13-%E6%9D%8E%E9%A3%9E%E9%A3%9E%E9%87%87%E8%AE%BF%E5%AE%9E%E5%BD%95/"/>
    <url>/13-%E6%9D%8E%E9%A3%9E%E9%A3%9E%E9%87%87%E8%AE%BF%E5%AE%9E%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>李飞飞WORLD LABS获得了2.3亿美元的投资，下面是她某次采访的核心观点</p><span id="more"></span><p><em><strong>最新事件</strong>：李飞飞WORLD LABS获得了2.3亿美元的投资，并接受彭博社采访，输出的核心观点：空间智能是一种可以理解、解释、生成真实世界，甚至可以与其交互的一种智能。这个真实的世界是由3D构成的，基础元素是像素，像图像就是二维的像素构成的。</em></p><div style="text-align: center;">  <img src="/images/FFL-7.jpg" alt="deploy_model" style="zoom:30%;" />   </div>  <div style="text-align: center;"> 2024年9月23日AI talk hosted by computer history mesum   </div>  <p>​                                              </p><p><strong>主持人：简要介绍下AI的发展历程？</strong><br><strong>飞飞</strong>：1990年代是AI的冬天，也是变革的开始。统计学方法流行，machine learning在NLP、计算机视觉、语音识别等场景上已经有所突破。李飞飞在2000年代当时还是博士生 ，神经网络已经诞生了。同时互联网开始诞生，意味着数据的产生和GPU的快速发展。2012 年之后，在华尔街开始诞生了很多AI的创业公司。不得不提及<strong>ImageNet</strong>（<strong>飞飞的代表作</strong>） 起源于2006，是一个数据集。1500万张图像，22000 物理的分类。开源的数据集，用于研究和挑战分类识别。AI的三个基本元素：<strong>神经网络（反向传播）、大数据、GPU计算</strong>。数据驱动神经网络和AI技术真正地被证明。</p><p><strong>飞飞</strong>：2016年AlphGO战胜了李世石。第一次让<strong>公众意识到</strong>计算机可以像人类一样思考，并且强于人类。也同时诞生了强化学习的概念。2016-2022 更多的投资在AI领域，Tech Clash， 自动驾驶2017。2022年10月 chatGPT诞生。在这之前gpt2已经让她意识到gpt的威力和强大之处。AlphaGO和ChatGPT的是让每个个体都接触到AI的技术。同时华盛顿政府注意到AI。</p><p><strong>飞飞</strong>：LLM （Large Language Model 大语言模型）的可解释性，模式识别、预测、甚至可以解释给你一些东西,也就是<strong>推理</strong>能力。</p><p><strong>主持人</strong>：如何评价此次AI的技术变革以及其带来的影响<strong>？</strong><br><strong>飞飞</strong>：这次AI 数字化变革，不仅仅是技术，更多地是让公众也就是普通人意识到AI技术带来的变革。语言只是一种智能化的形式，第一次工业革命和生物上DNA的发现也是智能。同时互联网的文本数据集已经几乎被挖掘尽了。她预测3-5年之后，不仅仅是商业化的进步比较明显，科学领域的研究发现也会更多。</p><p><strong>主持人</strong>：<strong>空间智能和具身机器人的发展如何看待？</strong><br>飞飞：距离很远，但是已经迫不及待。人类语言的学习，3D世界比语言的发展更早一些。规划你的生活、看见真实的世界，解释、生成与3D世界进行交互。</p><p><strong>主持人：AGI意味着什么？</strong><br>飞飞：AGI更多地是一个互联网工业化的用词，对于我们科技工作者来说，我会把它定义为 North-Star 问题。</p><p>PS: 有兴趣的朋友可以关注下ImageNet以及North-Star问题</p>]]></content>
    
    
    <categories>
      
      <category>AI技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微服务-SpringCloud技术总结</title>
    <link href="/12-SpringCloud%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <url>/12-SpringCloud%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>本文围绕Spring Cloud技术最进行详细介绍。</p><span id="more"></span><p>Eruka</p><p>Foeign</p><p>Hydrix</p><p>Spring Cloud Gateway</p><p>Spring Cloud Config</p><p>阿里巴巴Dubbo 或HSF技术</p>]]></content>
    
    
    <categories>
      
      <category>后端技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实时计算-Flink技术总结</title>
    <link href="/11-%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97flink/"/>
    <url>/11-%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97flink/</url>
    
    <content type="html"><![CDATA[<p>本文记录了Flink技术的一些基本概念和关键技术。</p><span id="more"></span><h4 id="Flink是什么？"><a href="#Flink是什么？" class="headerlink" title="Flink是什么？"></a>Flink是什么？</h4><p>​    实时流计算框架、无界数据</p><h4 id="同类竞品"><a href="#同类竞品" class="headerlink" title="同类竞品"></a>同类竞品</h4><p>   Spark Streaming（mini batch处理）</p><h5 id="与其他Hadoop生态之间的依赖关系"><a href="#与其他Hadoop生态之间的依赖关系" class="headerlink" title="与其他Hadoop生态之间的依赖关系"></a>与其他Hadoop生态之间的依赖关系</h5><p> Hbase作为外部存储（列式存储）应对大数据存储，背后是Htable，底层是HDFS数据。</p><p> Redis作为外部缓存，处理一些高频访问的场景，比如黑名单、白名单等</p><h4 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h4><p> 因为现实场景中有很多实时计算的场景，同时spark 有局限性。</p><h4 id="具体是如何实现的？"><a href="#具体是如何实现的？" class="headerlink" title="具体是如何实现的？"></a>具体是如何实现的？</h4><p><strong>部署框架</strong>：资源调度（Yarn、K8s、本地部署）、Job Manager（JobGraph、容灾等功能） 、 Task Manager（具体的执行节点）、后端state（内存、rocksDB或HDFS）</p><p><strong>资源是如何分配的</strong>： TaskSlot、相互之间通信（actor系统） 、内存管理（堆内、堆外内存）</p><p><strong>内部技术框架</strong>：算子（具体的计算逻辑，包括map、reduce、keyby、 groupby等）、窗口（用户侧接口，包括滑动窗口、翻转窗口等）、checkpoint（分布式快照） 、State（用于存储算子执行过程中的数据）、watermark机制</p><p><strong>几个关键的技术</strong>：State技术、Checkpoint技术、反压技术、exactly once技术、高性能技术、JobGraph技术</p><p><strong>Flink SQL 技术</strong></p><p>&#x2F;&#x2F; 待开始</p><h4 id="有哪些使用场景？"><a href="#有哪些使用场景？" class="headerlink" title="有哪些使用场景？"></a>有哪些使用场景？</h4><ol><li>计算当前微博热搜 TOP N</li><li>计算当前用户DAU、用户停留时长等</li></ol><h4 id="经典的一些问题"><a href="#经典的一些问题" class="headerlink" title="经典的一些问题"></a>经典的一些问题</h4><h5 id="1-性能出现瓶颈怎么办？如何进行调优？"><a href="#1-性能出现瓶颈怎么办？如何进行调优？" class="headerlink" title="1. 性能出现瓶颈怎么办？如何进行调优？"></a>1. 性能出现瓶颈怎么办？如何进行调优？</h5><p> <strong>问题定位</strong>： 否有反压、数据是否有倾斜 </p><p> <strong>解决方案</strong>：资源调整（并行度、作业参数调优、Java内存调优）、用户代码调优（数据打散、预聚合等）</p><h5 id="2-Exactly-once-是如何保证的？"><a href="#2-Exactly-once-是如何保证的？" class="headerlink" title="2. Exactly once 是如何保证的？"></a>2. Exactly once 是如何保证的？</h5><p>   checkpoint 、二阶段提交协议、下游保证分布式事务</p><h5 id="3-高性能技术有哪些？"><a href="#3-高性能技术有哪些？" class="headerlink" title="3. 高性能技术有哪些？"></a>3. 高性能技术有哪些？</h5><p>  &#x2F;&#x2F; TODO 待开始</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>消息队列-kafka rocketmq pulsar对比</title>
    <link href="/08-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94/"/>
    <url>/08-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<p>本文对常见的消息队列kafka rocketmq pulsar进行了全方位的对比，涉及部署架构、存储结构、网络通信层以及功能特性等方面。</p><span id="more"></span><h1 id="常见消息队列kafka-rocketmq-pulsar对比"><a href="#常见消息队列kafka-rocketmq-pulsar对比" class="headerlink" title="常见消息队列kafka rocketmq pulsar对比"></a>常见消息队列kafka rocketmq pulsar对比</h1><h2 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h2><img src="/images/deploy_model.jpg" alt="deploy_model" style="zoom:30%;" /><p>kafka：zookeeper集群、broker集群</p><p>RocketMq：NameServer集群、broker集群</p><p>Pulsar：bookeeper集群（日志存储系统）、broker集群 ，典型地计算与存储分离的架构。</p><h2 id="元数据存储"><a href="#元数据存储" class="headerlink" title="元数据存储"></a>元数据存储</h2><p>kafka：2.8版本以前是在zookeeper上存储 2.8版本之后，抛弃zookeeper，采用类似RAFT协议，主要考虑到当集群节点比较多，topic数量比较多时，zookeeper就会成为系统瓶颈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">/brokers<br>/broker/ids/   所有的broker节点，每个broker的配置文件中都需要指定一个数字类型的id<br>/broker/topics/  所有的topic注册信息；<br>/brokers/topics/[topic_name]/partitions/ 某个topic的partitions所有分配信息；<br><br>/controller<br>/controller_epoch Controller的选举次数（默认从<span class="hljs-number">1</span>开始）<br><br>/consumers<br>/consumers/[group_id]/ids/ Consumer订阅信息，每个consumer都有一个唯一的ID用来标记消费者信息；<br>/consumers/[group_id]/owners/[topic_name]/[partition_id]  consumer group对应的各个topic及partition的消费者线程。<br>/consumers/[group_id]/offsets/[topic_name]/[partition_id] consumer group对应的各个topic及partition的消费偏移量。<br><br>/admin<br>/admin/reassign_partitions  partition重分配信息；<br>/admin/preferred_replica_election 最优replica选举信息；<br>/admin/delete_topics  近期删除的topic；<br>/isr_change_notification/  ISR变更通知信息；<br>                 <br></code></pre></td></tr></table></figure><p>Rocketmq：存储在nameserver上</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>  kafka：</p><p> 通用的通信协议格式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-type">RequestMessage</span> =&gt; <span class="hljs-type">ApiKey</span> <span class="hljs-type">ApiVersion</span> <span class="hljs-type">CorrelationId</span> <span class="hljs-type">ClientId</span> <span class="hljs-type">RequestMessage</span><br>  <span class="hljs-type">ApiKey</span> =&gt; int16<br>  <span class="hljs-type">ApiVersion</span> =&gt; int16<br>  <span class="hljs-type">CorrelationId</span> =&gt; int32<br>  <span class="hljs-type">ClientId</span> =&gt; string<br>  <span class="hljs-type">RequestMessage</span> =&gt; <span class="hljs-type">MetadataRequest</span> | <span class="hljs-type">ProduceRequest</span> | <span class="hljs-type">FetchRequest</span> | <span class="hljs-type">OffsetRequest</span> | <span class="hljs-type">OffsetCommitRequest</span> | <span class="hljs-type">OffsetFetchReques</span><br></code></pre></td></tr></table></figure><p>  rocketmq：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<br>+ frame_size | header_length |         header_body        |     body     +<br>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<br>+   <span class="hljs-number">4</span>bytes   |     <span class="hljs-number">4</span>bytes    | (<span class="hljs-number">21</span> + r_len + e_len) bytes | remain bytes +<br>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<br></code></pre></td></tr></table></figure><p>  pulsar：</p><h3 id="通信框架"><a href="#通信框架" class="headerlink" title="通信框架"></a>通信框架</h3><p>kafka：基于Java NIO开发的kafka network 客户端</p><p>rocketMq：基于Netty异步网络I&#x2F;O通信框架开发，NettyRemotingClient和NettyRemotingServer</p><p>epoll和NIO的区别，NIO是select轮询，epoll是事件驱动。</p><p>pulsar：基于Netty异步网络I&#x2F;O通信框架开发。</p><img src="/Users/lyc/Desktop/code/interview_notes/Bigdata/kafka/rocketmq_netty.webp" alt="rocketmq_netty" style="zoom:30%;" /><h2 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h2><h3 id="存储与计算是否分离？"><a href="#存储与计算是否分离？" class="headerlink" title="存储与计算是否分离？"></a>存储与计算是否分离？</h3><img src="/images/mq_log_store.jpg" alt="mq_log_store" style="zoom:30%;" /><h3 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h3><p><strong>索引文件</strong>：Index文件，稀疏索引</p><p><strong>日志文件</strong>：存储每条日志</p><p>kafka：每个topic，每个分区，在一个日志文件中。</p><p>rocketmq：多个topic的分区记录可以存储在一个日志文件中 commit log</p><p>pulsar：每个topic每个分区的数据单独存储在bookeeper中</p><h3 id="刷盘机制"><a href="#刷盘机制" class="headerlink" title="刷盘机制"></a>刷盘机制</h3><p>异步刷盘、同步刷盘</p><h2 id="Producer层"><a href="#Producer层" class="headerlink" title="Producer层"></a>Producer层</h2><p>同步发送、异步发送（Callback或Future）、批量发送</p><p>重试机制：按照次数重发</p><p>ACK模式：kafka Ack&#x3D;-1，0， 1 不同模式，所有副本都确认，只有leader确认 不需要确认。</p><p>消息压缩机制：</p><h2 id="Consumer层"><a href="#Consumer层" class="headerlink" title="Consumer层"></a>Consumer层</h2><p>推拉模式：拉取-&gt;客户端主动拉取消息 推模式：服务端主动推送给客户端消息</p><p>Kafka: partition级别并行，consumer group 的每个consumer至多消费一个partition</p><p>rocketMq: 消费模式基本跟kafka类似，但是它支持<u>消息广播</u></p><p>pulsar：三种模式，独占模式、failover模式、共享模式，我们只讨论共享模式，consumer可任意扩展，不受partition分区数的限制。</p><p><strong>Rebalance</strong>：consumer group数量有变化的时候，分区与cosumer的消费关系重新被分配。</p><p><strong>顺序消费</strong>：</p><p>至少一次，exactly一次消费：</p><p><strong>回溯消费</strong>：offset重置位点</p><p><strong>重试机制</strong>：</p><h2 id="消息功能特性"><a href="#消息功能特性" class="headerlink" title="消息功能特性"></a>消息功能特性</h2><table><thead><tr><th>功能</th><th>kafka</th><th>rocketMQ</th><th>pulsar</th></tr></thead><tbody><tr><td><strong>消息轨迹查询</strong></td><td>不支持</td><td>支持</td><td></td></tr><tr><td><strong>延迟消息</strong></td><td>不支持</td><td>支持</td><td></td></tr><tr><td><strong>事务消息</strong></td><td>支持</td><td></td><td></td></tr><tr><td><strong>消息Tag</strong></td><td>不支持</td><td>支持</td><td></td></tr><tr><td><strong>死信队列</strong></td><td>不支持</td><td>支持</td><td></td></tr><tr><td><strong>顺序消息</strong></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>延迟消息的原理：</p><p>  延迟级别：1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</p><p>  原理：rocketmq支持不同级别的延迟消息，具体的实现策略是会有一个单独的topic ___xxx_topic 记录所有延迟topic的消息，这条消息会多一个属性，就是延迟的消息级别。然后会有一个定时任务消费这个topic去扫描，是否满足延迟条件，如果满足，则将这条消息发送到真正的topic上。</p><p><strong>死信队列</strong>：如果某条消息发送失败，会发送到一个默认的topic中，可以用这个队列做后面的重试工作等。</p><p><strong>消息TTL</strong>：也就是消息的过期时间</p><h2 id="高可用设计"><a href="#高可用设计" class="headerlink" title="高可用设计"></a>高可用设计</h2><h3 id="集群的Controller管理"><a href="#集群的Controller管理" class="headerlink" title="集群的Controller管理"></a>集群的Controller管理</h3><h3 id="分区的副本管理"><a href="#分区的副本管理" class="headerlink" title="分区的副本管理"></a>分区的副本管理</h3><p>kafka ISR的概念 每个分区都有Leader，N个副本，副本是异步拉取消息进行数据同步的。</p><p>plusar：写的时候，并行写的，而不是靠副本拉取同步。</p><p><strong>ACK机制</strong>：</p><h2 id="高可靠性"><a href="#高可靠性" class="headerlink" title="高可靠性"></a>高可靠性</h2><p><strong>刷盘策略</strong>：同步刷盘、异步刷盘</p><p>kafka是分区多副本 ，rocketmq 主备：master挂掉，slave切换服务</p><p>数据一致性：</p><p>kafka：弱一致性：</p><p>pulsar：强一致性</p><h2 id="高性能设计"><a href="#高性能设计" class="headerlink" title="高性能设计"></a>高性能设计</h2><p>PageCache：是操作系统的文件缓存机制。</p><p>Zero-Copy</p><p>顺序写磁盘</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网关-API网关核心技术</title>
    <link href="/06-API%E7%BD%91%E5%85%B3/"/>
    <url>/06-API%E7%BD%91%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>本文主要介绍了开放平台网关涉及的高性能、高可用等核心技术以及与开源的网关技术Spring Cloud gateway进行对比。</p><span id="more"></span>`<h2 id="功能架构图"><a href="#功能架构图" class="headerlink" title="功能架构图"></a>功能架构图</h2> <div style="text-align: center;">     <img src="/images/gatway_overview.png" alt="gatway_overview" style="zoom:30%;" /></div><p>API注册中心</p><p>数据中心</p><p>元数据缓存中心</p><h2 id="网关技术架构"><a href="#网关技术架构" class="headerlink" title="网关技术架构"></a>网关技术架构</h2> <div style="text-align: center;">      <img src="/images/api_gateway_deploy.png" alt="image" style="width: 300px; height: auto;" />  </div><p>业务网关：电商为主，对其他业务也通用</p><p>商业模式：商家 &lt;&#x3D;&gt; ISV &lt;&#x3D;&gt; 开放平台（网关+数据推送+电商云） &lt;&#x3D;&gt; 交易中台</p><p>技术模型：服务市场（ERP软件售卖给商家） + 开放平台控制台（ISV+应用+SDK+API文档）+ 电商云 + API内部开放</p><h2 id="网关分哪几种"><a href="#网关分哪几种" class="headerlink" title="网关分哪几种"></a>网关分哪几种</h2><p>流量网关、业务网关</p><p>南北向流量、东西向流量</p><p>硬件负载、软负载</p><p>中心化网关、去中心化网关</p><h2 id="核心指标"><a href="#核心指标" class="headerlink" title="核心指标"></a>核心指标</h2><h4 id="网关核心指标"><a href="#网关核心指标" class="headerlink" title="网关核心指标"></a>网关核心指标</h4><p>​性能指标：响应时间RT 、吞吐量QPS、HTTP请求成功率或失败率、<br>​稳定性指标：SLA可用性4个9<br>​业务指标：API的整体成功率、核心电商API的成功率</p><h4 id="ISV核心指标："><a href="#ISV核心指标：" class="headerlink" title="ISV核心指标："></a>ISV核心指标：</h4><p>​    迭代效率 </p><p>​     稳定性</p><h2 id="核心技术点"><a href="#核心技术点" class="headerlink" title="核心技术点"></a>核心技术点</h2><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h4><p>授权、权限认证、限流、路由、参数转化</p><p>南北向+业务网关</p><h4 id="Jetty有哪些比较好的设计？"><a href="#Jetty有哪些比较好的设计？" class="headerlink" title="Jetty有哪些比较好的设计？"></a>Jetty有哪些比较好的设计？</h4><p>Jetty（connector、线程池、Handler三部分）</p><p>I&#x2F;O模型（NIO）、池化技术、减少系统调用、零拷贝、高效的并发编程模型（用原子变量和CAS取代锁、ConcurrentLinkedQueue无锁化队列）</p><p><strong>问题：为什么是jetty，不采用netty？</strong></p><p>一个是servelet层面，一个是网络通信框架</p><p>Jetty原生支持http协议，netty更底层，灵活，需要实现自定义实现http协议的解析等</p><p>jetty是内置线程池，netty是reactor模型，可以深入定制线程模型</p><p>netty的学习曲线较高，netty高效的内存分配机制</p><h4 id="异步化具体是如何做的？"><a href="#异步化具体是如何做的？" class="headerlink" title="异步化具体是如何做的？"></a>异步化具体是如何做的？</h4><p>异步化：HSF异步化callback&#x2F;Jetty serverlet异步</p><h4 id="高性能缓存是如何做的？"><a href="#高性能缓存是如何做的？" class="headerlink" title="高性能缓存是如何做的？"></a>高性能缓存是如何做的？</h4><p>多层元数据缓存：bloomfiter&#x2F; 本地缓存&#x2F;分布式缓存</p><p>缓存穿透解决：采用bloom filter 或 缓存&lt;K,NULL&gt;可以解决，本处采用bloom filter ，猜测大概率是因为如何设置为null值的话，内存无限制增长。</p><p>本地缓存：采用LRU缓存</p><p>分布式缓存：tair中间件（类似redis）</p><h4 id="流控是如何做的？"><a href="#流控是如何做的？" class="headerlink" title="流控是如何做的？"></a>流控是如何做的？</h4><p>算法维度：令牌桶算法（可以应对突发流量） &#x2F; 漏桶算法（输出流量比较均匀）</p><p>机器维度：单机流控（高流量API，减少对redis缓存的调用）&#x2F;集群流控（低流量API）</p><p>业务维度：API&#x2F;Appkey&#x2F;API-Appkey&#x2F;天维度&#x2F;秒维度</p><p>实现方式：动态配置+redis的集群模式</p><h4 id="元数据缓存预热"><a href="#元数据缓存预热" class="headerlink" title="元数据缓存预热"></a>元数据缓存预热</h4><p>  所谓服务预热,就是在服务启动完成到对外提供服务之前,针对特定场景提供一些初始化准备操作,比如线程池预热、缓存预热、数据库预热、web预热和jvm预热等等</p><h4 id="隐私安全是如何做的？"><a href="#隐私安全是如何做的？" class="headerlink" title="隐私安全是如何做的？"></a>隐私安全是如何做的？</h4><p>安全：收货地址、手机号、姓名等进行加密、解密。加解密的技术细节是怎样的？</p><h4 id="去中心化是如何做的？"><a href="#去中心化是如何做的？" class="headerlink" title="去中心化是如何做的？"></a>去中心化是如何做的？</h4><p>为什么要做去中心化？以及是如何做的？</p><h4 id="云原生网关"><a href="#云原生网关" class="headerlink" title="云原生网关"></a>云原生网关</h4><p>lstio是东西向流量 sidecar 解决微服务之间的调用治理问题</p><p>为什么要进行云原生？如何做？</p><h4 id="压测是怎么做的？"><a href="#压测是怎么做的？" class="headerlink" title="压测是怎么做的？"></a>压测是怎么做的？</h4><ol><li>带压测标</li><li>数据mock</li><li>压测环境改造</li><li>影子表、缓存和MQ等</li><li>压测复盘</li></ol><h4 id="常见的排查指标以及排查思路"><a href="#常见的排查指标以及排查思路" class="headerlink" title="常见的排查指标以及排查思路"></a>常见的排查指标以及排查思路</h4><p>|              | 指标维度                           |<br>    | ———— | ———————————- |<br>| 业务接口     | 接口QPS、RT（TP99）                |<br>| Flink        | 反压、数据倾斜情况                 |<br>| 缓存         | 本地缓存、分布式缓存、缓存不一致   |<br>| 消息队列     | 数据消费进度                       |<br>| 数据库       | 并发事务、慢SQL                    |<br>| JVM          | GC情况&#x2F;Jstack&#x2F;线程池负载           |<br>| 操作系统     | 文件缓存、网络连接数、文件句柄数量 |<br>| 硬件         | CPU占用率&#x2F;磁盘&#x2F;网络情况            |<br>| 业务日志定位 | SLS日志                            |<br>| 全链路排查   | traceId，每个trace的调用情况       |<br>| 代码排查     | Arthas排查                         |</p><p>CPU利用率不高，线程数增大，GC频率无明显变化，RT变高，大概率是依赖的服务超时或者死锁</p><p>CPU利用率变高，线程数增大，GC频率明显变快，分析Jmap，有可能会有内存泄漏</p><p><u><em>引出：GC的相关知识点和线上排查日志的相关知识点</em></u></p><p>JVM GC常见的报错以及解决方案：</p><p><strong>Promotion Failure</strong>：Old区没有足够的空间来分配年轻代晋升的对象。</p><p><strong>Concurrent Mode Failure</strong>：Old区没有足够的空间来分配新的对象，此时垃圾回收器会退化成 serilaze </p><h2 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a>数据中心</h2><p><strong>作用</strong>：用于API审计、监控告警、API治理</p><p><strong>流程</strong>：集群异步写日志到本地磁盘-&gt;logtail-&gt;SLS-&gt;Flink SQL-&gt;hologress   </p><p>API维度、应用维度、商家维度、API-应用维度、分钟级、天级</p><p><strong>技术侧</strong>：FlinkSQL技术栈&#x3D;&#x3D;&gt; <em><u>引出实时计算知识点和数仓的相关技术</u></em></p><p>简单的Flink SQL的原理以及常见的业务优化技术</p><p><strong>业务侧</strong>：原始操作日志–&gt;中间进行小范围聚合，产生中间表 -&gt; 面向上层服务可用的数据</p><p>ODS（操作层） -&gt; DWM（中间层）–&gt;DWS（服务层），与传统的数仓少一个去重、过滤空值这一层</p><h2 id="API工作台"><a href="#API工作台" class="headerlink" title="API工作台"></a>API工作台</h2><p>API DevOps平台、API文档生成、API文档搜索（OpenSearch）</p><p>版本管理、API发布（自动化测试、灰度发布等功能）、监控告警、快速回滚等功能</p><h4 id="基于注解的二方包快速生成API"><a href="#基于注解的二方包快速生成API" class="headerlink" title="基于注解的二方包快速生成API"></a>基于注解的二方包快速生成API</h4><h4 id="基于HSF元数据快速生成API"><a href="#基于HSF元数据快速生成API" class="headerlink" title="基于HSF元数据快速生成API"></a>基于HSF元数据快速生成API</h4><h4 id="基于SmartEngine的工作流驱动API发布"><a href="#基于SmartEngine的工作流驱动API发布" class="headerlink" title="基于SmartEngine的工作流驱动API发布"></a>基于SmartEngine的工作流驱动API发布</h4><p><u>引出Spring 工厂模式、IOC和注解扫描+反射+代理</u></p><h2 id="智能答疑"><a href="#智能答疑" class="headerlink" title="智能答疑"></a>智能答疑</h2><p>从0到1搭建答疑体系，采用HanLP技术</p> <div style="text-align: center;">      <img src="/images/smartqa.jpg" alt="image" style="width: 400px; height: auto;" />  </div><p>引出插件化思想和概念，SPI &amp; 流程可编排</p><h2 id="SDK技术"><a href="#SDK技术" class="headerlink" title="SDK技术"></a>SDK技术</h2><p>客户端调用示例代码（JAVA语言举例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TaobaoClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultTaobaoClient</span>(url, appkey, secret);<br><span class="hljs-type">TradeFullinfoGetRequest</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TradeFullinfoGetRequest</span>();<br>req.setFields(<span class="hljs-string">&quot;tid,type,status,payment,orders,promotion_details&quot;</span>);<br>req.setTid(<span class="hljs-number">123456789L</span>);<br>req.setIncludeOaid(<span class="hljs-string">&quot;include_oaid&quot;</span>);<br><span class="hljs-type">TradeFullinfoGetResponse</span> <span class="hljs-variable">rsp</span> <span class="hljs-operator">=</span> client.execute(req, sessionKey);<br>System.out.println(rsp.getBody());<br></code></pre></td></tr></table></figure><p>GO语言、Java语言、Python语言、Net语言、C++语言等</p><p>基础包：HTTP调用、参数拼接、签名计算、返回结果反序列化</p><h4 id="验签的过程是怎样的？"><a href="#验签的过程是怎样的？" class="headerlink" title="验签的过程是怎样的？"></a>验签的过程是怎样的？</h4><h4 id="个性包文件是如何生成的？"><a href="#个性包文件是如何生成的？" class="headerlink" title="个性包文件是如何生成的？"></a>个性包文件是如何生成的？</h4><p>个性化包：DSL+模版引擎&#x3D;&gt; 代码生成</p><p>http连接是长连接还是短连接？ 回答：短连接。同时如果是长连接，需要客户端和服务端（Ngnix到后端服务器）也支持这种特性，目前是不支持这种特性的。</p><h4 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h4><p>多机房容灾</p><p>重试机制</p><p>引出kafka SDK和开放平台SDK的相似和不同之处：</p><p>kafka SDK核心解决消息的收发问题，本质上它屏蔽了网络层的一些通信细节</p><p>开放平台SDK核心解决：网关HTTP协议的拼接和验签过程，同时通过反序列化可以让开发者拿来即用数据结构。</p><h2 id="授权技术"><a href="#授权技术" class="headerlink" title="授权技术"></a>授权技术</h2><p>OAuth2 </p><p>服务端授权：code换token</p><h2 id="与其他框架对比"><a href="#与其他框架对比" class="headerlink" title="与其他框架对比"></a>与其他框架对比</h2><h3 id="Zuul2-0"><a href="#Zuul2-0" class="headerlink" title="Zuul2.0"></a>Zuul2.0</h3><h3 id="与开源框架Spring-Cloud-Gateway的对比"><a href="#与开源框架Spring-Cloud-Gateway的对比" class="headerlink" title="与开源框架Spring Cloud Gateway的对比"></a>与开源框架Spring Cloud Gateway的对比</h3><table><thead><tr><th></th><th>TOP</th><th>Spring Cloud Gateway</th></tr></thead><tbody><tr><td>业务</td><td>电商属性</td><td>一般通用</td></tr><tr><td>企业规模</td><td>大型</td><td>中小型</td></tr><tr><td>技术生态</td><td>HSF&#x2F;Diamond&#x2F;Sentiel</td><td>Eruka&#x2F;foregin&#x2F;robin&#x2F;configure等</td></tr><tr><td>路由配置</td><td>有单独的API配置中心</td><td>硬编码或yaml配置</td></tr><tr><td>技术框架</td><td>Jetty+HSF</td><td>Netty+Reactor webflux异步框架</td></tr><tr><td>异步化方式</td><td>Servelet 异步&#x2F;HSF异步</td><td>Reactor mnno框架&#x2F;Netty事件驱动异步</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>小问题：Spring Cloud的微服务之间为什么是http调用，而不是rpc调用？</p><p>Spring Cloud核心组件原理解析，补充一下。</p><p>foregin的源代码解析。</p><p>Spring Could Config 对标 Diamond</p><p>Spring Could Gateway 对标 API网关</p><p>Spring Eruka 对标 HSF 注册中心</p><p>Hydrix对标 Sentiel</p><h3 id="与Nginx-x2F-OpenResty的对比"><a href="#与Nginx-x2F-OpenResty的对比" class="headerlink" title="与Nginx&#x2F;OpenResty的对比"></a>与Nginx&#x2F;OpenResty的对比</h3><p>Nginx流量网关和 业务网关</p><p>Nginx反向代理和负载均衡是核心功能。</p><p>API网关负责将http请求路由到后端服务中，涉及鉴权、路由等</p><p>Nginx更多的是http请求的反向代理。</p><p>Nginx一般可以作为业务API网关的上游。</p><p>Nginx也可以做动静分离，就是将后端访问的静态资源放到nginx机器中，这样当访问到相应的url时，就会直接返回，而无需访问后端服务。</p><p>Nginx部署架构是进程模式，Master进程和多个worker进程，worker进程是Master进程的子进程，它们之间的通信是通过socket或管道</p><p>Nginx还有Cache的功能，有Cache Loader和Cache Manager进程</p><h3 id="与开源框架Kong的对比"><a href="#与开源框架Kong的对比" class="headerlink" title="与开源框架Kong的对比"></a>与开源框架Kong的对比</h3><p>Kong是流量网关，基于Nginx和Lua来实现的，支持开发插件。</p><p>可以基于K8S来部署</p><h3 id="与Service-Mesh的对比"><a href="#与Service-Mesh的对比" class="headerlink" title="与Service Mesh的对比"></a>与Service Mesh的对比</h3><p>中心化网关&#x3D;&#x3D;&#x3D;&gt; 去中心化网关&#x3D;&#x3D;&#x3D;&gt; mesh化网关架构</p><p>一个是横向（东西，微服务之间的）的流量、一个是纵向（南北）的流量</p><p>Service mesh 解决什么问题？解决微服务化后，各个应用之间的服务通信和治理问题。</p><p>什么是Side Car？解决什么问题？它本质上是一种设计模式，它允许应用程序依赖的组件以容器化或者独立进程的方式部署。</p>]]></content>
    
    
    <categories>
      
      <category>后端技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法-leetcode总结</title>
    <link href="/07-leetcode%E6%80%BB%E7%BB%93/"/>
    <url>/07-leetcode%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>本文详细介绍了leetcode相关分类与解法。</p><span id="more"></span><h2 id="核心分类"><a href="#核心分类" class="headerlink" title="核心分类"></a>核心分类</h2><p>一维数组</p><p>二维矩阵</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>快排</p><p>归并排序</p><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p><strong>满足：单调性、搜索结果收敛</strong>，注意 上界和下界</p><ol><li><p>搜索插入的位置</p></li><li><p>X的平方根</p></li><li><p><a href="https://www.cplusplus.com/reference/valarray/pow/">pow(x,n)</a>   递归进行计算 </p></li><li><p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">#153 寻找旋转排序数组中的最小值</a> </p></li><li><p>求复合某条件的最小值的最大值</p></li><li><p>求峰值</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPeakElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> nums.length-<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(l&lt;h)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l +(h-l)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(mid+<span class="hljs-number">1</span>&lt;nums.length &amp;&amp; nums[mid]&gt;nums[mid+<span class="hljs-number">1</span>])&#123;<br>                h=mid;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                l=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><ol><li><p>两数之和 第二轮</p></li><li><p>连续子数组之和大于目标值  <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">#209 长度最小的子数组</a>   【滑动窗口】有关</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">windowSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">minLen</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">while</span>(r&lt;nums.length)&#123;<br>        windowSum+= nums[r];<br>        <span class="hljs-keyword">while</span>(windowSum&gt;=target)&#123;<br>            minLen= Math.min(minLen,r-l+<span class="hljs-number">1</span>);<br>            windowSum -= nums[l];<br>            l++;<br>        &#125;<br>        r++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(minLen==Integer.MAX_VALUE)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> minLen;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>  <strong>Visited数组、访问过的变量List、终止条件、状态位标记复位和List回退</strong></p><ol><li><p>单词搜索 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>    <br>    <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[board.length][board[<span class="hljs-number">0</span>].length];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;board.length;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;board[<span class="hljs-number">0</span>].length;j++)&#123;<br>            <span class="hljs-comment">// 该节点为起点</span><br>            <span class="hljs-keyword">if</span>(backTrack(board,word,i,j,<span class="hljs-number">0</span>,visited))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>   <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>   <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board,String word,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> index,<span class="hljs-type">boolean</span>[][] visited)</span>&#123;<br>    <br>    <span class="hljs-comment">// 终止条件</span><br>    <span class="hljs-keyword">if</span>(index==word.length())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 边界条件</span><br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> || j&lt;<span class="hljs-number">0</span> || i&gt;=board.length || j&gt;=board[<span class="hljs-number">0</span>].length || visited[i][j] )&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(word.charAt(index)!=board[i][j])&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>   <br>    <span class="hljs-comment">// 遍历逻辑</span><br>    visited[i][j]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(backTrack(board,word,i+<span class="hljs-number">1</span>,j,index+<span class="hljs-number">1</span>,visited))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(backTrack(board,word,i,j+<span class="hljs-number">1</span>,index+<span class="hljs-number">1</span>,visited))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(backTrack(board,word,i-<span class="hljs-number">1</span>,j,index+<span class="hljs-number">1</span>,visited))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(backTrack(board,word,i,j-<span class="hljs-number">1</span>,index+<span class="hljs-number">1</span>,visited))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    visited[i][j]=<span class="hljs-literal">false</span>;<br>   <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>全排列 (无重复元素)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br> <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>     <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>     backTrack(nums,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(),visited);<br>     <span class="hljs-keyword">return</span> ret;<br> &#125;<br>    <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,List&lt;Integer&gt; list,<span class="hljs-type">boolean</span>[] visited)</span>&#123;<br>    <br>     <span class="hljs-comment">// 终止条件</span><br>     <span class="hljs-keyword">if</span>(list.size()==nums.length)&#123;<br>         ret.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>         <span class="hljs-keyword">return</span>;<br>     &#125;<br>    <br>     <span class="hljs-comment">// 逻辑</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>         <span class="hljs-keyword">if</span>(!visited[i])&#123;<br>             visited[i]=<span class="hljs-literal">true</span>;<br>             list.add(nums[i]);<br>             backTrack(nums,list,visited);<br>             list.remove(list.size()-<span class="hljs-number">1</span>);<br>             visited[i]=<span class="hljs-literal">false</span>;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li><li><p>全排列 (有重复元素)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>   <br>   <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>   <br>       <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>       Arrays.sort(nums);<br>       backTrack(nums, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(), visited);<br>   <br>       <span class="hljs-keyword">return</span> ret;<br>   &#125;<br>   <br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, List&lt;Integer&gt; list, <span class="hljs-type">boolean</span>[] visited)</span> &#123;<br>   <br>       <span class="hljs-comment">// 终止条件</span><br>       <span class="hljs-keyword">if</span> (list.size() == nums.length) &#123;<br>           ret.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>   <br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>   <br>           <span class="hljs-comment">// 去重</span><br>           <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !visited[i - <span class="hljs-number">1</span>]) &#123;<br>               <span class="hljs-keyword">continue</span>;<br>           &#125;<br>           <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>               visited[i] = <span class="hljs-literal">true</span>;<br>               list.add(nums[i]);<br>               backTrack(nums, list, visited);<br>               list.remove(list.size() - <span class="hljs-number">1</span>);<br>               visited[i] = <span class="hljs-literal">false</span>;<br>           &#125;<br>   <br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p></li><li><p>和为target的组合（无重复元素）<em>元素可以被多次使用</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>    backTrack(candidates,<span class="hljs-number">0</span>,target,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br>   <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> target,List&lt;Integer&gt; list)</span>&#123;<br>   <br>    <span class="hljs-comment">// 边界条件</span><br>    <span class="hljs-keyword">if</span>(target&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 终止条件</span><br>    <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)&#123;<br>        ret.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>   <br>    <span class="hljs-comment">// 遍历逻辑</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k;i&lt;nums.length;i++)&#123;<br>        list.add(nums[i]);<br>        backTrack(nums,i,target-nums[i],list); <br>        list.remove(list.size()-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>和为target的组合（有重复元素）<em>元素只能被使用一次</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br><br>      <br>        Arrays.sort(candidates);<br>        backTrack(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start, List&lt;Integer&gt; list)</span> &#123;<br>        <span class="hljs-comment">// 边界条件</span><br>        <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 终止条件</span><br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            ret.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] ) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <br>            list.add(nums[i]);<br>            backTrack(nums, target - nums[i], i+<span class="hljs-number">1</span>, list);<br>            list.remove(list.size() - <span class="hljs-number">1</span>);<br><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>电话号码的组合</p></li><li><p>括号生成（左括号数量+右边括号数量）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    backTrack(n,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>());<br>    <span class="hljs-keyword">return</span> ret;   <br>&#125;<br>   <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r,StringBuffer sb)</span>&#123;  <br>    <span class="hljs-comment">// 边界条件</span><br>    <span class="hljs-keyword">if</span>(l&gt;n || r&gt;n || r&gt;l )&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 终止条件</span><br>    <span class="hljs-keyword">if</span>(l==n &amp;&amp; r==n)&#123;<br>        ret.add(sb.toString());<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>   <br>    <span class="hljs-comment">// 遍历逻辑</span><br>   <br>    <span class="hljs-comment">// 左括号</span><br>    sb.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>    backTrack(n,l+<span class="hljs-number">1</span>,r,sb);<br>    sb.deleteCharAt(sb.length()-<span class="hljs-number">1</span>);<br>   <br>    <span class="hljs-comment">// 右括号</span><br>    sb.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>    backTrack(n,l,r+<span class="hljs-number">1</span>,sb);<br>    sb.deleteCharAt(sb.length()-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><ol><li>单词拆分（一个长word和List[]单词）（搜索+中间状态存储）</li><li>被围绕的区域，标记围绕的O为X <a href="https://leetcode.cn/problems/surrounded-regions/?envType=study-plan-v2&envId=top-interview-150">被围绕的区域</a> </li><li>岛屿的数量 第一轮</li><li><a href="https://leetcode.cn/problems/jump-game-ii/">#45 跳跃游戏 II</a> 贪心算法，本质上也是个搜索问题。</li></ol><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>什么情况下用贪心算法，贪心算法看起来比较简单，局部最优–&gt; 全局最优</p><p>我个人理解本质上是个搜索问题，只不过减枝了大部分不需要的搜索，那么问题来了，如何设计和寻找减枝的算法呢？先用暴力算法，然后再思考，有哪些不必要的计算？</p><ol><li>加油站⛽️问题  <a href="https://leetcode.cn/problems/gas-station/description/?envType=study-plan-v2&envId=top-interview-150">加油站</a>  O(n^2)–&gt;O(n) </li><li>买卖股票🏦的问题（一次和多次） </li><li>容器盛水问题 【贪心+双指针】O(n^2)–&gt;O(n) </li><li>跳跃游戏，<a href="https://leetcode.cn/problems/jump-game/?envType=study-plan-v2&envId=top-interview-150">跳跃游戏</a> <a href="https://leetcode.cn/problems/jump-game-ii/?envType=study-plan-v2&envId=top-interview-150">跳跃游戏2</a> nums[i]代表可以往前跳几步，是否可以到最后一步</li></ol><h3 id="链表-➡️➡️"><a href="#链表-➡️➡️" class="headerlink" title="链表 ➡️➡️"></a>链表 ➡️➡️</h3><ol><li><p>反转链表 </p></li><li><p>删除倒数K个节点 –快慢指针</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        dummy.next = head;<br><br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummy;<br>    <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;    <br>            fast = fast.next;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span> &amp;&amp; fast.next!=<span class="hljs-literal">null</span>)&#123;<br>            slow = slow.next;<br>            fast = fast.next;<br>        &#125;<br>        <br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> slow.next.next;<br>        slow.next = next;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>链表数学+1</p></li><li><p>有序链表的合并</p></li><li><p>环形链表 <a href="https://leetcode.cn/problems/linked-list-cycle?envType=study-plan-v2&envId=top-interview-150">环形链表</a>  【快慢指针】</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span> &amp;&amp; fast.next!=<span class="hljs-literal">null</span>)&#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>            <span class="hljs-keyword">if</span>(slow==fast)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>随机链表复制 【第一步 链表复制 &amp; 需要有一个Map保存 旧链表与新链表节点的映射，第二步 随机指针添加】</p></li><li><p><a href="https://leetcode.cn/problems/rotate-list/">#61 旋转链表</a>  【先找到尾部节点，并且计算链表长度；然后再找到倒数第K+1个节点，然后进行指针转化】</p></li><li><p>分隔链表 <a href="https://leetcode.cn/problems/partition-list/?envType=study-plan-v2&envId=top-interview-150">分隔链表</a> 第一轮</p></li></ol><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ol><li><p>最长连续不重复子字符串 </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">null</span> || s.length()==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;     <br>    Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>;<br>    map.put(s.charAt(<span class="hljs-number">0</span>),<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;s.length();i++)&#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> s.charAt(i);<br>        <span class="hljs-comment">// 更新start</span><br>        <span class="hljs-keyword">if</span>(map.get(cc)!=<span class="hljs-literal">null</span> &amp;&amp; map.get(cc)&gt;=start)&#123;<br>            start = map.get(cc)+<span class="hljs-number">1</span>; <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            len = Math.max(len,i-start+<span class="hljs-number">1</span>);<br>        &#125;<br>        map.put(cc,i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><ol><li><p>括号匹配 </p></li><li><p>用堆栈实现一个队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    <br>    Stack&lt;Integer&gt; popStack;<br>    Stack&lt;Integer&gt; pushStack;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        popStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        pushStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        pushStack.push(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        fillPopStack();<br>        <span class="hljs-keyword">return</span> popStack.isEmpty()?-<span class="hljs-number">1</span>:popStack.pop();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        fillPopStack();<br>        <span class="hljs-keyword">return</span> popStack.isEmpty()?-<span class="hljs-number">1</span>:popStack.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> popStack.isEmpty() &amp;&amp; pushStack.isEmpty();<br>    &#125;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fillPopStack</span><span class="hljs-params">()</span>&#123;<br>          <span class="hljs-keyword">if</span>(popStack.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(!pushStack.isEmpty())&#123;<br>                popStack.push(pushStack.pop());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最小栈 申请两个栈，一个原始的数据栈，另一个是保存当前最小值的栈。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span>  &#123;<br>    Stack&lt;Integer&gt; dataStack;<br><br>    Stack&lt;Integer&gt; minStack;<br><br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        dataStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        minStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        dataStack.push(x);<br>        <span class="hljs-keyword">if</span>(minStack.isEmpty())&#123;<br>            minStack.push(x);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">peek</span> <span class="hljs-operator">=</span> minStack.peek();<br>            minStack.push(Math.min(peek,x));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        dataStack.pop();<br>        minStack.pop();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(dataStack.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dataStack.peek();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(minStack.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minStack.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>单调栈（也就是说栈中的元素是单调的，递增或递减，一般用来解决符合某种单调条件的差值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// leetcode 739 日常温度 </span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        <span class="hljs-comment">// stack 存储的是未被处理的数据，一旦满足条件，就处理，pop，stack的元素满足某种单调条件</span><br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[temperatures.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; temperatures.length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">peek</span> <span class="hljs-operator">=</span> stack.pop();<br>                ret[peek] = i - peek;<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>在Java中的数据结构叫 优先队列，默认是最小堆。如果是最大堆，需要改下compare函数。</p><h3 id="二叉树-🌲"><a href="#二叉树-🌲" class="headerlink" title="二叉树 🌲"></a>二叉树 🌲</h3><p><strong>本质上是搜索【从上往下、从下往上、前、中、后】 解题思路：1. 从上往下搜索的过程中引入全局存储，可以记录搜索的路径等 2. 递归&#x2F;递归一般是从下往上传递结果值，也可以是从下往上按照规则进行搜索，从上反推。</strong></p><p><strong>递归结果的值再进行逻辑判断。</strong></p><ol><li><p>前、中、后序遍历</p></li><li><p>层次遍历（右视图、Z之形打印等）</p></li><li><p>判断对称树</p></li><li><p>二叉树最近公共祖先  review</p></li><li><p>二叉树转为链表  （PreNode和左右child节点提前保存）</p></li><li><p>二叉树+target数字，是否存在根节点到叶子结点之和为目标值。</p></li><li><p>二叉树+target数字，不一定是根节点到叶子结点，但是肯定是从父节点到子节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum)</span> &#123;<br>     <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">return</span> pathSumFrom(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);<br> &#125;<br>   <br> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSumFrom</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">long</span> sum)</span> &#123;<br>     <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">return</span> (node.val == sum ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>)<br>             + pathSumFrom(node.left, sum - node.val) + pathSumFrom(node.right, sum - node.val);<br> &#125;<br></code></pre></td></tr></table></figure></li><li><p>二叉树的直径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    dfs(root);<br>    <span class="hljs-keyword">return</span> maxLen;<br>&#125;<br>   <br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> dfs(root.left);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dfs(root.right);<br>    maxLen = Math.max(l+r, maxLen);<br>    <span class="hljs-keyword">return</span> Math.max(l,r)+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li></li></ol><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><ol><li><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">#230 二叉搜索树中第K小的元素</a>  中序遍历 O(K)</li><li><a href="https://leetcode.cn/problems/validate-binary-search-tree?envType=study-plan-v2&envId=top-interview-150">验证二叉搜索树</a> </li><li>验证二叉搜索树的后序遍历序列是否合法 再看下</li><li>二叉搜索树最近公共祖先</li><li><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">#530 二叉搜索树的最小绝对差</a>  【中序遍历+前置节点】 </li><li>判断是否为二叉搜索树 <a href="https://leetcode.cn/problems/validate-binary-search-tree/?envType=study-plan-v2&envId=top-interview-150">判断是否为二叉搜索树</a> 【中序遍历+数值区间】</li></ol><h3 id="动态规划-🟪🟪➡️🟪🟪"><a href="#动态规划-🟪🟪➡️🟪🟪" class="headerlink" title="动态规划 🟪🟪➡️🟪🟪"></a>动态规划 🟪🟪➡️🟪🟪</h3><ul><li>前置状态存储的含义</li><li>状态转移方程  </li><li>一维和多维</li></ul><ol><li>最长回文子串  dp[i][j]&#x3D;true&#x2F;false代表是否是回文串【二维】O(N^2)</li><li>最小路径和   向➡️向⬇️ 移动【二维】  O(N^2)</li><li>最长递增子序列 【一维】F[N]代表小于等于nums[N]的子数组的最大长度 O(N^2)</li></ol><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>本质上是个搜索问题，按照“业务逻辑”搜索，并且标记状态，然后继续进行搜索。</p><ol><li>最长连续序列–先保存数据，然后再进行连续数字搜索。 </li><li>合并区间  – 先排序，再合并 O(NLogN)</li><li></li></ol><h2 id="错题本❌"><a href="#错题本❌" class="headerlink" title="错题本❌"></a>错题本❌</h2><ol><li>优先队列，默认是最小堆。</li><li>二分搜索，注意边界条件，使用[1,2] 和[1,2,3]作为测试用例验证</li><li>回溯，注意终止条件，以及visited、以及状态回溯等。</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列-Kafka原理</title>
    <link href="/04-Kafka%E5%8E%9F%E7%90%86/"/>
    <url>/04-Kafka%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>本文主要介绍了kafka的核心设计原理，从客户端、网络层、存储层、高可用、高性能分别做了介绍。</p><span id="more"></span><h1 id="Kafka-端到端源码解析"><a href="#Kafka-端到端源码解析" class="headerlink" title="Kafka 端到端源码解析"></a>Kafka 端到端源码解析</h1><h2 id="Kafka的场景"><a href="#Kafka的场景" class="headerlink" title="Kafka的场景"></a>Kafka的场景</h2><p>削峰、异步化（Kafka-&gt;Spring框架）、流式处理（Kafka-&gt;Spark&#x2F;Flink）</p><h2 id="Kafka概念"><a href="#Kafka概念" class="headerlink" title="Kafka概念"></a>Kafka概念</h2><ul><li><strong>Broker</strong></li><li><strong>Topic</strong></li><li><strong>Partition</strong>   逻辑上最小的单元</li><li><strong>Offset</strong></li><li><strong>LogSegment</strong>   文件存储最小的单元</li><li><strong>Producer</strong>   生产者</li><li><strong>Consumer</strong>   消费者</li><li><strong>Zookeeper</strong>  提供分布式协调服务</li><li><strong>Controller</strong>   集群中的master</li><li><strong>ISR(In-Sync-Replica)</strong>   Topic分区的副本状态</li><li><strong>脑裂</strong> 集群中出现了双主，对于kafka来说是双controller</li><li><strong>羊群效应</strong> 当zookeeper上一个znode节点发生变化时，所有监听该节点的客户端都会发生相应的动作</li></ul><h2 id="Topic-创建与删除"><a href="#Topic-创建与删除" class="headerlink" title="Topic 创建与删除"></a>Topic 创建与删除</h2><p>   zk注册，controller选举具体的数据结构与流程</p><h3 id="Topic状态流转"><a href="#Topic状态流转" class="headerlink" title="Topic状态流转"></a>Topic状态流转</h3><p>   创建、在线、增加分区、下线、删除</p><h3 id="Topic-一些问题"><a href="#Topic-一些问题" class="headerlink" title="Topic 一些问题"></a>Topic 一些问题</h3><ul><li>topic分区数可不可以减少？如果可以，为什么？<br><br><strong>不可以</strong></li><li>Kafka 目前有哪些内部topic？分别的作用是什么？<br><br><strong>__consumer_offset</strong> 用来保存用户groupId对应的消费topic offset</li></ul><h3 id="Topic分区初始化选择"><a href="#Topic分区初始化选择" class="headerlink" title="Topic分区初始化选择"></a>Topic分区初始化选择</h3><p>  按照broker数量均匀地分布在每个broker上</p><h2 id="Kafka-Producer解析"><a href="#Kafka-Producer解析" class="headerlink" title="Kafka Producer解析"></a>Kafka Producer解析</h2><h3 id="1-发送流程"><a href="#1-发送流程" class="headerlink" title="1. 发送流程"></a>1. 发送流程</h3><ul><li>第一步： 刷新元数据</li><li>第二步： 序列化、选择分区、注册拦截器回调函数</li><li>第三步： 往RecordAccmulator发送数据</li><li>第四步：判断batch是否满了，满了的话唤醒send后台线程 <br><br><strong>有可能的异常：API版本不匹配；Buffer耗尽等</strong></li><li>第五步 ： send后台线程退出时，扫尾工作</li></ul><h3 id="2-分区选择策略？"><a href="#2-分区选择策略？" class="headerlink" title="2. 分区选择策略？"></a>2. 分区选择策略？</h3><ul><li>若该消息内无指定分区，则使用消息中指定的key哈希生成的分区</li><li>若key为null，则按照轮询的方式生成分区</li><li>最后一种，若仍然不满足需求，用户还可以自己指定partition分区策略类，每条消息都按照这个策略进行  <br><br>因此，分区策略可以有四个级别：用户自定义分区策略类、key哈希、轮询、任一消息选择任一分区，总的来说给用户很大的自由度。</li></ul><h3 id="3-拦截器有什么作用？"><a href="#3-拦截器有什么作用？" class="headerlink" title="3. 拦截器有什么作用？"></a>3. 拦截器有什么作用？</h3><p>在每次消息处理成功后增加一个回调函数，一般用来记录一些统计信息，为每条消息增加其他字段等等。</p><h3 id="4-关键数据结构"><a href="#4-关键数据结构" class="headerlink" title="4. 关键数据结构"></a>4. 关键数据结构</h3><p>RecordAccmulator数据结构的作用</p><p>的内部是如何运作的？这是个线程安全的数据结构</p><p>ConcurrentHashMap《TopicPartition，Batch队列》</p><p>Batch队列需要保证线程安全</p><p>有一个缓冲池bufferPool，每次开始是已经有batch在发，如果不存在则开辟batchSize大小的空间；然后往Batch队列的append数据，并且使得offset+1,然后会生成一个FutureRecordMetadata，用来表示batch是否满</p><p><strong>消息在如何在客户端存储的</strong>   <br><br>MemoryRecord 定义了一条消息在内存中的存储，</p><p>传输到socketChannel</p><h3 id="5-参数配置"><a href="#5-参数配置" class="headerlink" title="5.  参数配置"></a>5.  参数配置</h3><ol><li>batch.size指的是大小，不是消息数</li><li>ling.ms是每隔该时间就定时发送</li><li>maxFlightPerConnection&#x3D;1保证了消息在单分区内的顺序性</li></ol><h3 id="6-ACK机制"><a href="#6-ACK机制" class="headerlink" title="6. ACK机制"></a>6. ACK机制</h3><p> 代表对于消息可靠性的容忍度 <br><br> Ack&#x3D;1 代表leader返回ack即可 Ack&#x3D;-1 代表所有副本返回ack Ack&#x3D;0代表不需要返回</p><h3 id="7-Producer一些问题"><a href="#7-Producer一些问题" class="headerlink" title="7. Producer一些问题"></a>7. Producer一些问题</h3><ul><li>kafka 分区器、序列化器、拦截器之间的处理顺序？<br><br><strong>序列化器、分区器、 拦截器</strong>（发送完成后才会调用）</li><li>如何保证topic消息顺序性？<br><br><strong>全局消息顺序性</strong>：采用一个topic partition<br><strong>单分区顺序性</strong>：  maxFlightPerConnection&#x3D;1</li><li>性能调优问题？</li><li>数据压缩问题？</li><li>数据幂等性？<br><br>kafka 0.11版本之后提供了producer的幂等性</li><li>kafka 生产者客户端用了几个线程 <br><br> sender线程、producer主线程、</li></ul><h2 id="Kafka网络接收层"><a href="#Kafka网络接收层" class="headerlink" title="Kafka网络接收层"></a>Kafka网络接收层</h2><h3 id="Kafka-channel"><a href="#Kafka-channel" class="headerlink" title="Kafka channel"></a>Kafka channel</h3><h3 id="如何做限流的？"><a href="#如何做限流的？" class="headerlink" title="如何做限流的？"></a>如何做限流的？</h3><p>图中展示了通用的限流算法<br><img src="/throught_controller.png" alt="avatar"></p><p>server&#x2F;ClientQuatoManager负责进行流量控制</p><h3 id="如何做数据安全的？"><a href="#如何做数据安全的？" class="headerlink" title="如何做数据安全的？"></a>如何做数据安全的？</h3><h4 id="PageCache、mmap、zero-copy在kafka中的场景分别是什么？"><a href="#PageCache、mmap、zero-copy在kafka中的场景分别是什么？" class="headerlink" title="PageCache、mmap、zero-copy在kafka中的场景分别是什么？"></a>PageCache、mmap、zero-copy在kafka中的场景分别是什么？</h4><p>PageCache是文件缓存，属于操作系统层面的优化 –这个一般用来数据的缓存</p><p>mmap是内存映射文件 【MappedByteBuffer】用于index文件的读写</p><p>zero-copy是指在sendfile函数，可以直接从操作系统的文件中转移到网络channel 中，不需要走内核中转。在java中是fileChannel的trasferTo函数</p><p>那么这几个在kafka中，分别使用的是什么函数？ </p><p>ByteBuffer 堆内、、DirectByteBuffer</p><p>文件读写相关接口：FileChannel</p><p>zero-copy相关接口：linux中 sendFile()，java中是trasferTo</p><h2 id="Kafka内存管理"><a href="#Kafka内存管理" class="headerlink" title="Kafka内存管理"></a>Kafka内存管理</h2><h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><p>堆外内存主要用在kafka consumer中，一般为了提高I&#x2F;O效率，都采用NIO的方式读取文件，而读取后的数据都保存在ByteBuffer数据结构中，ByteBuffer封装了堆外内存的引用。<br>ByteBufferMessageSet 解读</p><h2 id="kafka-存储层解析"><a href="#kafka-存储层解析" class="headerlink" title="kafka 存储层解析"></a>kafka 存储层解析</h2><p>存储层是利用本地文件系统的文件来存储的，首先每个topic对应N个分区，每个分区对应有三类文件（log文件、index文件与timeindex文件）。Log文件以每条二进制序列化后的消息为基本单位存储消息，每条消息的基本格式如下表格，而log文件分为很多个logsegment，每个segment的大小是一样的，例如1GB，三个文件的名字为文件中第一个消息的offset数值。</p><h3 id="消息格式-V1版本"><a href="#消息格式-V1版本" class="headerlink" title="消息格式(V1版本)"></a>消息格式(V1版本)</h3><table><thead><tr><th>filed</th><th>size</th><th>desciption</th></tr></thead><tbody><tr><td>offset</td><td>8 B</td><td>偏移量</td></tr><tr><td>message size</td><td>4 B</td><td>消息大小</td></tr><tr><td>crc32</td><td>4 B</td><td>crc校验码</td></tr><tr><td>magic</td><td>1B</td><td>Api的版本</td></tr><tr><td>timestamp</td><td>8 B</td><td>消息时间戳</td></tr><tr><td>attributes</td><td>1 B</td><td>属性？</td></tr><tr><td>key length</td><td>4 B</td><td>key的长度</td></tr><tr><td>key</td><td></td><td>key的消息体</td></tr><tr><td>value length</td><td>4B</td><td>value长度</td></tr><tr><td>value</td><td></td><td>消息体长度</td></tr></tbody></table><h3 id="消息索引"><a href="#消息索引" class="headerlink" title="消息索引"></a>消息索引</h3><ol><li><strong>给定时间戳—&gt;定位某个LogSegment—&gt;定位offset—&gt;定位消息位置?</strong> <br><br>根据时间戳查找offset，先顺序定位到LogSegment（找到第一个大于该时间戳的LogSegment),然后timeindex内部二分查找定位到offset</li><li><strong>给定offset—&gt; 定位到某个LogSegment—&gt;定位消息位置 ?</strong> <br><br> 根据offset，跳表中定位到LogSegment,然后index内部二分查找定位到offset位置，再顺序搜索定位到文件位置</li></ol><h3 id="刷盘策略"><a href="#刷盘策略" class="headerlink" title="刷盘策略"></a>刷盘策略</h3><p>kafka是异步刷盘的，有后台线程专程将内存中的数据写入到磁盘中<br>index 文件通过mmap从磁盘映射到用户空间内存中，log文件则是普通的读取文件。</p><h3 id="日志清理与Compaction"><a href="#日志清理与Compaction" class="headerlink" title="日志清理与Compaction"></a>日志清理与Compaction</h3><h3 id="流程与数据结构"><a href="#流程与数据结构" class="headerlink" title="流程与数据结构"></a>流程与数据结构</h3><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><ul><li>谈谈你对页缓存、内核层、块层、设备层的理解  <br><br>内核层 ：操作系统中的内存数据与用户态buffer进行相互拷贝<br><br>pagecache : 文件读到操作系统内存中，操作系统的内存管理系统会预读 <br><br>块层：管理设备I&#x2F;O队列，对I&#x2F;O请求进行合并、排序等<br>设备层：通过DMA与内存直接交互，将数据写到磁盘</li></ul><h2 id="副本管理"><a href="#副本管理" class="headerlink" title="副本管理"></a>副本管理</h2><p>为什么用ISR，不用Raft之类的协议？借鉴了PacificA算法协议。 两个重要的组件：配置管理（对应kafka ISR，leader epoch commited_point) <br><br>&#x3D;&#x3D;HighWaterMark的作用：commited 消息度量；读可见性&#x3D;&#x3D;<br><a href="http://www.thinkingyu.com/articles/PacificA/">参考</a></p><h3 id="Failover机制"><a href="#Failover机制" class="headerlink" title="Failover机制"></a>Failover机制</h3><ul><li>若unclean.leader.election.enable为true，再去replica中去找存活的broker。而ISR中的broker存在是这样：只有当follower从leader拉取数据跟得上leader的数据速度时，才会在ISR中，否则，被剔除掉ISR列表中。</li><li>若unclean.leader.election.enable为false，抛出异常</li></ul><p>为什么会有unclean.leader.election.enable这个参数呢？</p><p>那么数据一致性是如何保证的呢，如何知道副本的状态是可靠的？ISR就保存了kafka认为可靠的副本，它们具备这样的条件：1 . 落后leader的消息条数在一定阈值内 2.或者落后在一定时间内；<br>但是，follower的复制状态谁又能保证一定能跟得上leader呢？这样，就存在着一种可能性，有可能ISR中只有leader,其他的副本都跟不上leader; 因此，这个时候，patition到底可用不可用？这就是一个权衡了，若只从ISR中获取leader，保证了数据的可靠性，但partition就不可用了，若从replica中获取，则可用性增强，但是数据可能存在丢失情况。<br>因此unclean.leader.election.enable这个参数设计为true，则保证了可用性，也就是CAP中的A P;设置为false，则保证了数据一致性，也就是CAP中的CP</p><h2 id="kafka-Consumer解析"><a href="#kafka-Consumer解析" class="headerlink" title="kafka Consumer解析"></a>kafka Consumer解析</h2><h3 id="推拉模型"><a href="#推拉模型" class="headerlink" title="推拉模型"></a>推拉模型</h3><p>推: 主动给客户端推送消息 【客户端可能会overload】<br>拉：客户端主动向服务端拉取消息 【服务端可能会overload】</p><p>commit消息存储：这个数据保存在zk上</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="Rebalance的原理"><a href="#Rebalance的原理" class="headerlink" title="Rebalance的原理"></a>Rebalance的原理</h4><p>groupcordernator 负责 消费者offset管理以及消费者 rebalance</p><p>group-&gt;多个memberid</p><p>第一次加入的过程：</p><ol><li>第一次加入–&gt;随机选取一个broker作为GroupCoordinator–&gt;选取一个member作为leader</li><li>member进行 分区的分配，定义好后，发送给GroupCoordinator</li><li>GroupCoordinator将这个分区分配信息同步给其他所有member</li></ol><p>什么场景下会触发rebalance</p><ol><li>有新的memer加入</li><li>有member掉线</li><li>topic的分区有增加</li><li>GroupCoordinator所在的broker fail</li></ol><h3 id="一些问题-1"><a href="#一些问题-1" class="headerlink" title="一些问题"></a>一些问题</h3><ul><li>kafka 如何做到不重复消费? <br><br>现有的kafka可以做到写幂等性（0.11版本之后），但是做不到消费幂等性。消费完后写offset到zk失败，这个状态consumer客户端是感知不到的，二者并没有类似TCP的ack机制。因此下一次还是会从上次提交的offset继续读，就会出现重复消费。我个人觉得解决这个问题可以从两个方向来考虑：应用端做消费幂等性处理，也即每条消息会有一个全局的key，应用端保存消费过消息的key，每次新消费一条数据，key做重复判断，若重复，则丢弃这条数据。当然这会带来额外的内存与查询开销。<br><br>  同样，应用端也就是consumer端需要消息处理和offset提交这两步是事务的，也即要么操作成功要么撤回恢复之前的状态。这需要应用端有事务保障，但往往很多应用端是不支持事务的，比如kafka数据落盘hdfs，kafka数据消费完写入本地文件等等。但官方给的kafka consumer-process-kafka 给出了一个不错的参考的例子和思路。基本上遵循了分布式系统中的两阶段提交想法和思路，<a href="http://matt33.com/2018/11/04/kafka-transaction/">具体可以参见</a></li></ul><p>个人理解重复消费出现的概率并不会很高，在服务端改进会带来很大的性能损耗，这可能是为什么大家都选择不处理的重要原因吧。另外，本身系统与系统之间传输数据，很难做到消息的exactly once的。无论是kafka到存储系统hdfs还是spark flink下游计算系统等。若数据传输都在一个系统之内，那相对好处理一些，比如kafka的事务，保证了consume-process-producer的事务场景，也就是从kafka消费处理完毕后再到kafka，这个可以做到exactly once。</p><h2 id="zookeeper的作用"><a href="#zookeeper的作用" class="headerlink" title="zookeeper的作用"></a>zookeeper的作用</h2><h3 id="zookeeper在kafka中的作用"><a href="#zookeeper在kafka中的作用" class="headerlink" title="zookeeper在kafka中的作用"></a>zookeeper在kafka中的作用</h3><ol><li><strong>controller选举</strong>，所有的broker在zk &#x2F;controller下注册临时节点，任意一个抢先的broker注册成功，则为controller</li><li><strong>kafka consumer负载均衡</strong></li><li><strong>集群节点存活状态监测</strong></li><li><strong>topic创建触发</strong></li><li><strong>broker上线、下线的通知</strong></li><li><strong>ISR配置变更</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件,消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程框架-Spring技术总结</title>
    <link href="/10-Spring%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <url>/10-Spring%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>本文围绕Spring技术最核心的是IOC和AOP的两个概念进行详细介绍。</p><span id="more"></span><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>IOC是控制反转，传统的编程情况下，如果一个对象依赖另一个对象，是需要程序员自己定义和初始化一个对象的。现在在Spring框架下，初始化的工作交给了Spring。Spring来负责管理这部分工作。那么具体是如何管理的呢？</p><ol><li>扫描类与类之间的关系</li><li>有一个对象容器，存放每个对象</li></ol><h2 id="关键过程"><a href="#关键过程" class="headerlink" title="关键过程"></a>关键过程</h2><p>有几个关键的概念：SpringContext  BeanFactory  FactoryBean</p><h2 id="常见的问题："><a href="#常见的问题：" class="headerlink" title="常见的问题："></a>常见的问题：</h2><h4 id="如果存在循环依赖怎么办？"><a href="#如果存在循环依赖怎么办？" class="headerlink" title="如果存在循环依赖怎么办？"></a>如果存在循环依赖怎么办？</h4><p>  spring三层缓存</p><h4 id="Spring生命周期可以用来做什么？"><a href="#Spring生命周期可以用来做什么？" class="headerlink" title="Spring生命周期可以用来做什么？"></a>Spring生命周期可以用来做什么？</h4><p>   初始化、属性赋值</p><p>   PostProcess afterproerset</p><h4 id="FactoryBean-跟-BeanFactory有什么区别？"><a href="#FactoryBean-跟-BeanFactory有什么区别？" class="headerlink" title="FactoryBean 跟 BeanFactory有什么区别？"></a>FactoryBean 跟 BeanFactory有什么区别？</h4><p>  FactoryBean是一种特殊的bean，一般使用场景是将繁琐的初始化事项屏蔽，对外提供一个Bean，比如与数据库的连接</p><p>  BeanFactory是用来生产Bean的，它提供了通用的接口。</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP是面向切面编程。面向切面相当于对一段函数进行能力强化，一般场景是打印日志、权限控制等。那么它是如何实现的呢？</p><p> 动态代理，使用JDK动态代理或者CGLIB进行代理，JDK是利用<strong>反射机制</strong>，对有实现<strong>接口的类</strong>进行代理。CGLIB是通过生成子类来实现的。JDK代理是本身JDK自带的。CGLIB是一个外部库，它是通过字节码agent技术</p><p>具体实现方式</p><p>设计模式：</p><p>工场模式、责任链模式、代理模式、单例模式、适配器模式</p><h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><p>如果让你设计mysql高可用方案的话，你会优先考虑哪些方面</p><p>2、抖音评论系统怎么设计，如果加入好友关系呢？（考虑到数据读取的性能，可以采用写扩散的方式）</p><p>3、怎么设计一个短链地址，要考虑跨机房部署问题</p><p>你说要哈希算法生成短链，会存在什么问题（哈希冲突），该怎么解决？（可以用布隆过滤器，但是不好控制，而且仍存在hash冲突）</p><p>有没有更好的方案？（自增序列算法，每次接收一个长链，就分配一个ID，转成62进制再拼到短域后面）</p><p>存在的问题？（自增id方案如果用雪花算法，可能存在机器时钟回拨的问题，导致id重复，说到这里，我终于明白那家伙为什么说要考虑跨机房部署问题）</p><p>该怎么解决？（用Redis做自增id生成器，性能高，但要考虑持久性的问题；或者改造雪花算法，通过改造workId解决时钟回拨的问题）</p>]]></content>
    
    
    <categories>
      
      <category>后端技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AI技术-大模型工程技术汇总</title>
    <link href="/01-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB/"/>
    <url>/01-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>本文记录一下最近一个月学习的大模型相关的技术知识点，为拥抱AI浪潮做些技术储备。</p><span id="more"></span>`<h2 id="大模型术语相关"><a href="#大模型术语相关" class="headerlink" title="大模型术语相关"></a><strong>大模型术语相关</strong></h2><h3 id="参数规模"><a href="#参数规模" class="headerlink" title="参数规模"></a><strong>参数规模</strong></h3><p>GPT 3.5 千亿级别</p><p>GPT4 1.8W亿级别</p><p>国内一般都是十亿或百亿级别</p><p>ChatGLM2_2K_6B </p><p>BAICHUAN_4K_13B</p><p>淘宝星辰_4K_13B</p><h3 id="TOKEN长度"><a href="#TOKEN长度" class="headerlink" title="TOKEN长度"></a><strong>TOKEN长度</strong></h3><p>Token是指被LLM处理的离散的数据单元，可能是一个单词、也可能是一个字符，这个是由上下文决定的。</p><p>TOKEN数量是指 输入和输出加起来的长度之和</p><p>TOKEN数量，决定了 prompt和输出的长度，同样会影响推理的速度，prompt越长，推理时间越长。</p><p><strong>TOKEN的数量为什么会有上限，是有什么限制么？</strong></p><h3 id="各个版本的token数量限制"><a href="#各个版本的token数量限制" class="headerlink" title="各个版本的token数量限制"></a><strong>各个版本的token数量限制</strong></h3><p>GPT3.5-turbo 是4096个token</p><p>GPT3.5_16K</p><p>GPT4_Turbo_128K</p><p><strong>大模型工程落地相关</strong></p><h3 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a><strong>prompt</strong></h3><p>零样本</p><p>少样本：通过举例</p><p>思维链</p><p>角色、限制条件</p><h3 id="LangChain"><a href="#LangChain" class="headerlink" title="LangChain"></a><strong>LangChain</strong></h3><p>软件开发框架，帮助开发者快速且灵活地调用大模型，也封装了许多常见的chain，可以被业务快速使用。</p><h3 id="Semantic-Kernel"><a href="#Semantic-Kernel" class="headerlink" title="Semantic-Kernel"></a><strong>Semantic-Kernel</strong></h3><p>微软的一个工程框架，也可以实现langchain的基本功能，不过更适用于多agent的框架。</p><h3 id="RAG（检索增强生成）"><a href="#RAG（检索增强生成）" class="headerlink" title="RAG（检索增强生成）"></a><strong>RAG（检索增强生成）</strong></h3><p>是一种结合外部知识库来增强LLM生成能力的总称。</p><h3 id="向量数据库"><a href="#向量数据库" class="headerlink" title="向量数据库"></a><strong>向量数据库</strong></h3><p>Embedding：将现实世界中的物质向量化到高维空间，向量距离通常代表了自然语言的语义相似度。</p><p>召回：向量召回、搜索召回</p><h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a><strong>Agent</strong></h3><p>简单来说是具有某个功能的原子能力，可以被大模型调用到。</p><h3 id="多Agent"><a href="#多Agent" class="headerlink" title="多Agent"></a><strong>多Agent</strong></h3><p>多个agent协同完成一个目标，比如metaGPT</p><p><strong>大模型训练相关</strong></p><h3 id="预训练"><a href="#预训练" class="headerlink" title="预训练"></a><strong>预训练</strong></h3><p>通过大量的数据训练出来的模型</p><h3 id="推理"><a href="#推理" class="headerlink" title="推理"></a><strong>推理</strong></h3><p>模型根据已有的经验，对用户的输入进行预测。</p><h3 id="微调"><a href="#微调" class="headerlink" title="微调"></a><strong>微调</strong></h3><p>预训练好的模型在特定的任务上进行微调，使用有标签的小规模数据集</p><h3 id="训练基础设施"><a href="#训练基础设施" class="headerlink" title="训练基础设施"></a><strong>训练基础设施</strong></h3><p>pytorch 是一种深度学习框架，用来训练大模型的，transformer是一种模型机制。</p><h3 id="计算资源"><a href="#计算资源" class="headerlink" title="计算资源"></a><strong>计算资源</strong></h3><p>CPU：传统的CPU芯片，重逻辑，轻计算。</p><p>GPU：类众核CPU，重计算，轻逻辑。A100 H100 4096等，代表了不同的算力，常见的衡量指标有Flops</p><p>TPU ：谷歌出的类似于GPU的芯片</p><h2 id="LangChain框架"><a href="#LangChain框架" class="headerlink" title="LangChain框架"></a><strong>LangChain框架</strong></h2><h3 id="1-LangChain解决什么问题"><a href="#1-LangChain解决什么问题" class="headerlink" title="1. LangChain解决什么问题"></a><strong>1. LangChain解决什么问题</strong></h3><p>LangChain是基于LLM之上的，在应用层和底层LLM之前的一个很好的编程框架，如果把LLM比喻为各种类型的数据库、中间件等这些基础设施，应用层是各种业务逻辑的组合之外，那么LangChain就负责桥接与业务层和底层LLM模型，让开发者可以快速地实现对接各种底层模型和快速实现业务逻辑的软件开发框架。</p><p>那么LangChain是如何做到的呢？试想一下，现在底层有一个大模型的推理能力，除了在对话框手动输入跟他聊天之外。如何用计算机方式跟它互动呢？如果把一次LLM调用当作一个原子能力，如何编排这些原子能力来解决一些业务需求呢？Langchain就是来解决这个事情的。</p><h3 id="2-LangChain的几个核心概念"><a href="#2-LangChain的几个核心概念" class="headerlink" title="2. LangChain的几个核心概念"></a><strong>2. LangChain的几个核心概念</strong></h3><h4 id="格式化数据（I-x2F-O）"><a href="#格式化数据（I-x2F-O）" class="headerlink" title="格式化数据（I&#x2F;O）"></a><strong>格式化数据（I&#x2F;O）</strong></h4><h4 id="Retriver"><a href="#Retriver" class="headerlink" title="Retriver"></a><strong>Retriver</strong></h4><p>检索是为了解决大模型打通用户的本身数据，做一些面向业务属性的东西。这里的检索并非传统的关系型数据库，更多的是与大模型的本身逻辑相似的，比如向量数据库。</p><p><strong>一个经典的结合LLM和外部用户的文档进行智能答疑的场景</strong></p><p>文档-&gt;分词-&gt;embedding-&gt;向量数据库</p><p>query-&gt;向量数据库查询-&gt;TOP N-&gt;上下文+ 用户提问 + prompt -&gt; LLM -&gt; 返回结果</p><p>一个经典的图如下：</p><p><img src="https://pic1.zhimg.com/80/v2-d05ae1eea26c6ce55b3a98cf7a8870cc_1440w.jpg?source=d16d100b" alt="img"></p><p>添加图片注释，不超过 140 字（可选）</p><p><strong>关键技术：文档如何拆分、embedding过程、 TOPN 向量距离的选择</strong></p><p>embedding技术选型</p><p>embedding是将现实中的物体通过向量化的方法转化为高维向量，可被机器学习模型所识别。他是一种映射，同时也保证了能清晰地表达现实物体的特征。基于此，可以进行一些归类分析、回归分析等。</p><p>现在市面上常见的embedding方法有通义千问的embedding等方法。</p><p>向量数据库</p><p>向量数据库底层存储的是一堆向量，它提供了根据向量相似度进行查询的能力，一般情况下，向量相似度代表了现实世界中物体的相似度。比如”我的名字是小明“ 和“我叫小明”这两句话所代表的含义几乎是相同的，那么在embedding之后，基于向量数据库进行查询的时候，它们俩的相似度就会很近。</p><h4 id="Chain"><a href="#Chain" class="headerlink" title="Chain"></a><strong>Chain</strong></h4><p>各种类型的chain，chain代表了各种业务类型的组合，类似于工作流的编排。</p><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a><strong>Memory</strong></h4><p>LLM本身提供了记忆的能力，同时提供了接口，开发者可以将历史的对话记录传入给LLM。LangChain需要使用外部存储保存这些历史的会话和记忆。可以使用数据库、缓存等进行保存。</p><h4 id="Agent-1"><a href="#Agent-1" class="headerlink" title="Agent"></a><strong>Agent</strong></h4><p><strong>重点是代理工具</strong></p><p>代理工具可以让应用程序基于大模型的推理能力，然后进行代理工具或代理服务的调用。因为LLM是没有“联网”的能力的，如果想解决特定的应用场景，代理工具是个完美的选择。</p><p>代理工具通常包含三个方面： 用户输入、prompt编排LLM思考与路由代理的过程、背后的代理服务。其中难点可能就在于prompt设计了。通常的“套路”是这样的：</p><p><strong>ReAct 模型</strong></p><p>输入：用户的问题</p><p>思考过程：如果是情况1（这个是需要LLM进行意图识别进行思考的），那么推理和提取出一些关键参数，调用agent1，如果是情况2，那么推理和提取出一些关键参数，调用agent2</p><p>Act：调用agent1对应一个JSON格式化的输入，调用function1，返回结果。</p><p>观察：观察调用后的结果，再结合推理的能力，再进行循环思考。</p><h2 id="Semantic-Kernel-框架"><a href="#Semantic-Kernel-框架" class="headerlink" title="Semantic Kernel 框架"></a>Semantic Kernel 框架</h2><p>功能基本与langchain功能相同，在应用层和LLM层中间实现了一个编程框架。框架可以灵活、快速地对接LLM模型，帮助开发者可以快速落地AI业务。</p><h3 id="1-Kernel"><a href="#1-Kernel" class="headerlink" title="1. Kernel"></a><strong>1. Kernel</strong></h3><p><img src="https://picx.zhimg.com/80/v2-9daba1e0791e6fb0bda2a39cf98a0d22_1440w.png?source=d16d100b" alt="img"></p><p>添加图片注释，不超过 140 字（可选）</p><p>kernel都包含哪些？</p><h4 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a><strong>上下文</strong></h4><p>主要包含三部分：</p><p>ContextVariables，用来存储LLM中间返回结果，是一个全局的运行时变量存储，方便各agent或各skfunction进行引用。</p><p>SemanticTextMemory：管理内存，这里可以类比向量化数据库。</p><p>ReadOnlySkillCollection 管理注册的skill与function这些元数据。</p><h4 id="SkFunction"><a href="#SkFunction" class="headerlink" title="SkFunction"></a><strong>SkFunction</strong></h4><p>SKFunction是一个具体功能的描述，包含 description、prompt、以及大模型相关的参数配置项，比如温度值等</p><p>skill是一组function功能的集合</p><h4 id="Planner"><a href="#Planner" class="headerlink" title="Planner"></a><strong>Planner</strong></h4><p>对解决一个复杂场景问题，结合一堆function，设定一个goal，给出LLM思考逻辑，生成具体执行计划，然后调用skfunction</p><h4 id="PlugIn"><a href="#PlugIn" class="headerlink" title="PlugIn"></a><strong>PlugIn</strong></h4><p>与真实世界进行对接，让LLM有“联网”的能力，可以是API接口，也可以是向量数据库、也可以是本地函数等等。</p><h3 id="2-Demo实践"><a href="#2-Demo实践" class="headerlink" title="2. Demo实践"></a><strong>2. Demo实践</strong></h3><p>代码：官网上下载的JAVA版本</p><h4 id="基础的问答"><a href="#基础的问答" class="headerlink" title="基础的问答"></a><strong>基础的问答</strong></h4><ol><li><strong>kernel构建</strong></li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static Kernel get<span class="hljs-constructor">Kernel(OpenAIProxyClient <span class="hljs-params">client</span>)</span> &#123;<br>        Kernel kernel = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SKBuilders</span>.</span></span>kernel<span class="hljs-literal">()</span><br>                .<span class="hljs-keyword">with</span><span class="hljs-constructor">DefaultAIService(SKBuilders.<span class="hljs-params">chatCompletion</span>()</span><br>                        .<span class="hljs-keyword">with</span><span class="hljs-constructor">ModelId(<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)</span><br>                        .<span class="hljs-keyword">with</span><span class="hljs-constructor">OpenAIClient(<span class="hljs-params">client</span>)</span><br>                        .build<span class="hljs-literal">()</span>)<br>                .build<span class="hljs-literal">()</span>;<br><br>        return kernel;<br>    &#125;<br></code></pre></td></tr></table></figure><ol><li><strong>skill和function编写，提示词和gpt参数设置</strong></li></ol><p><img src="https://pic1.zhimg.com/80/v2-d5c34467c0e87752dcdc080c412e11e7_1440w.png?source=d16d100b" alt="img"></p><p>添加图片注释，不超过 140 字（可选）</p><ol><li><strong>引入skill与function</strong></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">ReadOnlyFunctionCollection skill = kernel.importSkillFromDirectory(&quot;FunSkill&quot;, SampleSkillsUtil.detectSkillDirLocation(), &quot;FunSkill&quot;);<br><br>        CompletionSKFunction <span class="hljs-keyword">function</span> = skill.getFunction(&quot;Joke&quot;,<br>                CompletionSKFunction.<span class="hljs-keyword">class</span>);<br><br>        Mono&lt;SKContext&gt; result = <span class="hljs-keyword">function</span>.invokeAsync(&quot;赵本山和宋丹丹要在2024年出一个小品&quot;);<br><br>        <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(result.block().getResult());<br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="多Agent执行完成一个目标"><a href="#多Agent执行完成一个目标" class="headerlink" title="多Agent执行完成一个目标"></a><strong>多Agent执行完成一个目标</strong></h4><p>以Example_PlanWithNativeFunctions 为例子，这个例子接收用户指令：给Steven发一封邮件，并且有限使用Steven的备注名，具体的函数有：<strong>Emailer 邮件功能</strong> 、<strong>寻找人名的备注名称、以及字符串替换的功能</strong></p><ol><li><strong>Plan通用思考提示词（SK系统）</strong></li></ol><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">To <span class="hljs-keyword">create</span> a plan, follow these steps:<br><span class="hljs-number">0.</span> The plan should be <span class="hljs-keyword">as</span> short <span class="hljs-keyword">as</span> possible.<br><span class="hljs-number">1.</span> <span class="hljs-keyword">From</span> a &lt;goal&gt; <span class="hljs-keyword">create</span> a &lt;plan&gt; <span class="hljs-keyword">as</span> a series of &lt;functions&gt;.<br><span class="hljs-number">2.</span> Before <span class="hljs-keyword">using</span> <span class="hljs-keyword">any</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">in</span> a plan, check that it <span class="hljs-keyword">is</span> present <span class="hljs-keyword">in</span> the most recent [AVAILABLE FUNCTIONS] list. <span class="hljs-keyword">If</span> it <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span>, <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">use</span> it. <span class="hljs-keyword">Do</span> <span class="hljs-keyword">not</span> assume that <span class="hljs-keyword">any</span> <span class="hljs-keyword">function</span> that was previously defined <span class="hljs-keyword">or</span> used <span class="hljs-keyword">in</span> another plan <span class="hljs-keyword">or</span> <span class="hljs-keyword">in</span> [EXAMPLES] <span class="hljs-keyword">is</span> automatically available <span class="hljs-keyword">or</span> compatible <span class="hljs-keyword">with</span> the current plan.<br><span class="hljs-number">3.</span> Only <span class="hljs-keyword">use</span> functions that are required <span class="hljs-keyword">for</span> the given goal.<br><span class="hljs-number">4.</span> A <span class="hljs-keyword">function</span> has a single <span class="hljs-string">&#x27;input&#x27;</span> <span class="hljs-keyword">and</span> a single <span class="hljs-string">&#x27;output&#x27;</span> which are both strings <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> objects.<br><span class="hljs-number">5.</span> The <span class="hljs-string">&#x27;output&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">is</span> automatically passed <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;input&#x27;</span> <span class="hljs-keyword">to</span> the subsequent &lt;<span class="hljs-keyword">function</span>&gt;.<br><span class="hljs-number">6.</span> <span class="hljs-string">&#x27;input&#x27;</span> does <span class="hljs-keyword">not</span> need <span class="hljs-keyword">to</span> be specified <span class="hljs-keyword">if</span> it consumes the <span class="hljs-string">&#x27;output&#x27;</span> of the previous <span class="hljs-keyword">function</span>.<br><span class="hljs-number">7.</span> <span class="hljs-keyword">To</span> save an <span class="hljs-string">&#x27;output&#x27;</span> <span class="hljs-keyword">from</span> a &lt;<span class="hljs-keyword">function</span>&gt;, <span class="hljs-keyword">to</span> pass <span class="hljs-keyword">into</span> a future &lt;<span class="hljs-keyword">function</span>&gt;, <span class="hljs-keyword">use</span> &lt;<span class="hljs-keyword">function</span>.&#123;FunctionName&#125; ... setContextVariable: <span class="hljs-string">&quot;&lt;UNIQUE_VARIABLE_KEY&gt;&quot;</span>/&gt;<br><span class="hljs-number">8.</span> <span class="hljs-keyword">To</span> save an <span class="hljs-string">&#x27;output&#x27;</span> <span class="hljs-keyword">from</span> a &lt;<span class="hljs-keyword">function</span>&gt;, <span class="hljs-keyword">to</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">as</span> part of a plan result, <span class="hljs-keyword">use</span> &lt;<span class="hljs-keyword">function</span>.&#123;FunctionName&#125; ... appendToResult: <span class="hljs-string">&quot;RESULT__&lt;UNIQUE_RESULT_KEY&gt;&quot;</span>/&gt;<br><span class="hljs-number">9.</span> Append an <span class="hljs-string">&quot;END&quot;</span> XML comment at the <span class="hljs-keyword">end</span> of the plan<br></code></pre></td></tr></table></figure><ol><li><strong>生成执行计划–XML文件（SK系统）</strong></li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;function.Names.getNickName <span class="hljs-attribute">input</span>=<span class="hljs-string">&quot;Steven&quot;</span> <span class="hljs-attribute">setContextVariable</span>=<span class="hljs-string">&quot;NICKNAME&quot;</span>/&gt;<br>  &lt;function.StringFunctions.stringReplace <span class="hljs-attribute">from</span>=<span class="hljs-string">&quot;USER_NAME&quot;</span> <span class="hljs-attribute">input</span>=<span class="hljs-string">&quot;Hello, USER_NAME. This is an important message for you.&quot;</span> <span class="hljs-attribute">to</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$NICKNAME</span>&quot;</span> <span class="hljs-attribute">setContextVariable</span>=<span class="hljs-string">&quot;REPLACED_MESSAGE&quot;</span>/&gt;<br>  &lt;function.Emailer.getEmailAddress <span class="hljs-attribute">input</span>=<span class="hljs-string">&quot;Steven&quot;</span> <span class="hljs-attribute">setContextVariable</span>=<span class="hljs-string">&quot;EMAIL_ADDRESS&quot;</span>/&gt;<br>  &lt;function.Emailer.sendEmail <span class="hljs-attribute">emailaddress</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$EMAIL_ADDRESS</span>&quot;</span> <span class="hljs-attribute">message</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$REPLACED_MESSAGE</span>&quot;</span> <span class="hljs-attribute">subject</span>=<span class="hljs-string">&quot;Important Message&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><ol><li><strong>定义每个SKFunction的功能以及接收的输入参数（用户自定义）</strong></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@DefineSKFunction</span>(name = <span class="hljs-string">&quot;getEmailAddress&quot;</span>, description = <span class="hljs-string">&quot;Retrieves the email address for a given user&quot;</span>)<br>        <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getEmailAddress</span>(<span class="hljs-params"></span><br><span class="hljs-params">                <span class="hljs-meta">@SKFunctionInputAttribute</span>(description = <span class="hljs-string">&quot;The name of the person to get an email address for&quot;</span>)</span><br><span class="hljs-params">                <span class="hljs-built_in">String</span> name</span>) &#123;<br>            <span class="hljs-keyword">switch</span> (name) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Steven&quot;</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;codeking@example.com&quot;</span>;<br>                <span class="hljs-attr">default</span>:<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Unknown user: &quot;</span> + name);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><ol><li><strong>使用Plan进行调用</strong></li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">kernel.import<span class="hljs-constructor">Skill(<span class="hljs-params">new</span> StringFunctions()</span>, <span class="hljs-string">&quot;StringFunctions&quot;</span>);<br>kernel.import<span class="hljs-constructor">Skill(<span class="hljs-params">new</span> Emailer()</span>, <span class="hljs-string">&quot;Emailer&quot;</span>);<br>kernel.import<span class="hljs-constructor">Skill(<span class="hljs-params">new</span> Names()</span>, <span class="hljs-string">&quot;Names&quot;</span>);<br><br>SequentialPlanner planner = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SequentialPlanner(<span class="hljs-params">kernel</span>, <span class="hljs-params">null</span>, <span class="hljs-params">null</span>)</span>;<br><br><br>Plan plan = planner<br>.create<span class="hljs-constructor">PlanAsync(<span class="hljs-string">&quot;Send the input as an email to Steven and make sure I use his preferred name in the email&quot;</span>)</span><br>.block<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><h3 id="3-思考"><a href="#3-思考" class="headerlink" title="3. 思考"></a><strong>3. 思考</strong></h3><p>与LangChain的对比</p><table><thead><tr><th></th><th>LangChain</th><th>Semantic Kernel</th></tr></thead><tbody><tr><td>开发组织</td><td>社区</td><td>微软</td></tr><tr><td>设计理念</td><td>Model I&#x2F;O 、 Retriver、Chain、Memory</td><td>Kernel、SKFunction、ContextVar、Plan、Plugin</td></tr><tr><td>支持语言</td><td>python</td><td>python&#x2F;c#&#x2F;java，主推python与c#</td></tr><tr><td>社区活跃</td><td>活跃，功能迭代很快</td><td>比LangChain慢</td></tr><tr><td>生态集成</td><td>集成了各种Model I&#x2F;O</td><td>生态集成没有LangChain高</td></tr><tr><td>记忆能力</td><td>支持</td><td>支持</td></tr><tr><td>支持多LLM切换</td><td>支持</td><td>支持</td></tr><tr><td>RAG支持</td><td>支持Retriver</td><td>支持Memory</td></tr><tr><td>Agent支持</td><td>支持</td><td>支持</td></tr><tr><td>多Agent支持</td><td>支持LangGraph</td><td>支持Planner</td></tr></tbody></table><h3 id="4-其他思考"><a href="#4-其他思考" class="headerlink" title="4. 其他思考"></a>4. <strong>其他思考</strong></h3><p>Semantic kernel 的function与planner 抽象的比较好，可以通过planner来实现复杂场景的企业级AI应用。LangChain更适合快速落地一个AI应用，已经沉淀了各种Chain，拿来即用。同时LangChain已经推出LangGraph了，已经在实现类似Planner的功能。</p><h2 id="Embeding技术"><a href="#Embeding技术" class="headerlink" title="Embeding技术"></a><strong>Embeding技术</strong></h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a><strong>1. 介绍</strong></h3><p>将现实世界中的信息映射到低维的向量空间上。机器学习训练中的一个环节，在大模型产生之前就已经有了。</p><h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a><strong>2. 应用场景</strong></h3><h4 id="RAG向量召回场景"><a href="#RAG向量召回场景" class="headerlink" title="RAG向量召回场景"></a><strong>RAG向量召回场景</strong></h4><p><img src="https://picx.zhimg.com/80/v2-069230cff445aa6ce54cfd682623e812_1440w.jpg?source=d16d100b" alt="img"></p><p>添加图片注释，不超过 140 字（可选）</p><p>RAG使用中的场景</p><h4 id="机器学习训练特征提取"><a href="#机器学习训练特征提取" class="headerlink" title="机器学习训练特征提取"></a><strong>机器学习训练特征提取</strong></h4><p>降维、特征提取、数据压缩等</p><h3 id="3-如何生成向量"><a href="#3-如何生成向量" class="headerlink" title="3. 如何生成向量"></a><strong>3. 如何生成向量</strong></h3><p><strong>常用embedding技术</strong></p><p>一般分为在线服务和离线服务</p><p><a href="https://huggingface.co/spaces/mteb/leaderboard%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E4%BB%8B%E7%BB%8D%E4%BA%86%E5%BD%93%E5%89%8D%E4%B8%BB%E6%B5%81%E7%9A%84%E4%B8%80%E4%BA%9Bembedding%E6%8A%80%E6%9C%AF%E4%BB%A5%E5%8F%8A%E6%8E%92%E8%A1%8C%E6%A6%9C%E6%83%85%E5%86%B5%E3%80%82">https://huggingface.co/spaces/mteb/leaderboard这个网站介绍了当前主流的一些embedding技术以及排行榜情况。</a></p><p>目前了解到的一些embedding技术包括：Word2Vec、通义千问embedding、text-embedding-3-small and text-embedding-3-large <a href="https://platform.openai.com/docs/guides/embeddings/what-are-embeddings">openAI embedding</a></p><p><strong>图像embedding</strong></p><p>一般用于图像分类、目标检测、计算机视觉等，不详细展开。</p><p><strong>视频embedding</strong></p><p>一般用于视频检索、视频内容理解、视频推荐等，不详细展开</p><h3 id="4-如何计算相似度"><a href="#4-如何计算相似度" class="headerlink" title="4. 如何计算相似度"></a><strong>4. 如何计算相似度</strong></h3><p>欧几里得距离</p><p><img src="https://pic1.zhimg.com/80/v2-e441bbd7f8e5eab87e94f99f5719e82e_1440w.jpg?source=d16d100b" alt="img"></p><p>添加图片注释，不超过 140 字（可选）</p><p>余弦距离</p><p><img src="https://picx.zhimg.com/80/v2-92c959d665fd0523f99f1eb37d5daca1_1440w.jpg?source=d16d100b" alt="img"></p><p>添加图片注释，不超过 140 字（可选）</p><p>曼哈顿距离</p><p><img src="https://picx.zhimg.com/80/v2-e8838f2a88a955927ae3b379ea0a10ba_1440w.jpg?source=d16d100b" alt="img"></p><p>添加图片注释，不超过 140 字（可选）</p><h3 id="5-代码示例"><a href="#5-代码示例" class="headerlink" title="5. 代码示例"></a><strong>5. 代码示例</strong></h3><p>文本：“你是谁”？</p><p>方法：通义千问在线embedding</p><p>结果：</p><p><img src="https://picx.zhimg.com/80/v2-71319122f67b1ce1786ca70ef3b3ab6a_1440w.jpg?source=d16d100b" alt="img"></p><p>添加图片注释，不超过 140 字（可选）</p><p>1500+维度的空间向量</p><h3 id="6-思考"><a href="#6-思考" class="headerlink" title="6. 思考"></a><strong>6. 思考</strong></h3><p>1.Embedding作为召回策略中的一种，不同的embedding模型可能会对召回产生不同的影响，最好与LLM本身采用的embedding技术保持一致。</p><p>2.向量召回只是RAG召回策略中的一种，还包括搜索召回等其他方法。</p><h2 id="微调技术"><a href="#微调技术" class="headerlink" title="微调技术"></a><strong>微调技术</strong></h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>最近尝试了<strong>RAG技术</strong>实现了基于LLM上的智能答疑，也尝试了工作流的生成，发现效果严重依赖于大模型的能力，同时好的大模型成本又比较高，每次调用需要从知识库中召回大量的文档，从而消耗大量的token，所以在思考是否可以尝试通过将这些文档微调到大模型上。同时在思考是否也不需要超大参数的模型，是否可以基于小模型和业务数据来微调出自己的业务垂直模型。</p><p>同时我发现微调也没那么容易上手，因为这对于将来模型调试后的效果还是挺重要的，同时，理解一点基础的原理还是有必要的，仅仅是参照网上的教程一步步执行命令行，不晓得其中的原理，很容易一头雾水。</p><h3 id="2-什么是预训练模型"><a href="#2-什么是预训练模型" class="headerlink" title="2. 什么是预训练模型"></a><strong>2. 什么是预训练模型</strong></h3><p>其实在之前已经有预训练模型的一些概念了。比如CNN、RNN等。其大概原理是每次训练，与目标值计算得出损失值，反向传播驱动模型迭代更新，使得下一代迭代更精确。</p><p><strong>CNN</strong>：适合于图像领域</p><p><strong>RNN</strong>：适合于自然语言NLP</p><p><strong>Transformer</strong>模型：基于RNN之上增加了并行处理和注意力机制的特性。</p><h3 id="3-什么是微调"><a href="#3-什么是微调" class="headerlink" title="3. 什么是微调"></a><strong>3. 什么是微调</strong></h3><p><strong>在已经训练好的大模型基础上，使用特定的数据集进行进一步的训练，以使模型适应特定任务或领域</strong>。有一个例子解释的挺好：小明刚刚学会了开车，那么他已经掌握了一些基础的开车技巧，比如起步、踩油门、转弯、换挡、靠边停车等一些基础技能。在微调的过程中，小明要适应在湿滑的泥地、大雾天气、山路陡坡、雨雪天等场景下开车，以适应新的场地要求。</p><h3 id="4-什么情况下微调"><a href="#4-什么情况下微调" class="headerlink" title="4. 什么情况下微调"></a><strong>4. 什么情况下微调</strong></h3><p>训练自己垂直领域的大模型，以适应自己特定领域的任务， 但是<strong>数据规模小，同时计算资源又稀缺</strong>。</p><h3 id="5-为什么会有不同的微调方法？"><a href="#5-为什么会有不同的微调方法？" class="headerlink" title="5. 为什么会有不同的微调方法？"></a><strong>5. 为什么会有不同的微调方法？</strong></h3><p>假设我们把训练过程简单定义为：Y（真实结果）&#x3D;W（模型）*X（输入）</p><p>Y&#x3D;[y1,y2,y3,y4,y5…yn] X&#x3D;[x1,x,2,x3,…xm]，Y和X是Embeding之后的矩阵向量，那么最后优化的就是这个W。</p><p>那么对于新的数据集X和Y，如何优化W，一种办法是W中加入一些低纬度的矩阵权重，另一种办法是X做一些演变，根据数据集去优化W。以下就是几种方法的基本原理。</p><h3 id="6-几种方法"><a href="#6-几种方法" class="headerlink" title="6. 几种方法"></a><strong>6. 几种方法</strong></h3><p><strong>LoRA</strong></p><p>新权重 &#x3D; 原始权重 + AB。</p><p>Y &#x3D;(W*@W)*X</p><p>数学上的含义：假设 预训练模型是训练中间的神经网络，我们把最终生成的这个“神经网络” 比喻成是矩阵<strong>变换A X 矩阵变化B X 矩阵变化C</strong> ….，那么最终生成的预训练模型就是超大规模的矩阵变化集合。那么微调就是在这个超大规模的矩阵变化中，加入一些<strong>低纬度的矩阵变化</strong>，通过训练给入的小规模入参，优化这些低纬度的矩阵变化过程，最终来适应这个特定领域的“逻辑”</p><p><strong>Prompt Tuning</strong></p><p>Y &#x3D; WX&#96;</p><p>就是在输入端加入一些提示词，以增大生成期望结果的概率。简单来说：给定预训练模型的参数，然后在模型的输入端添加可学习的”prompt”（提示）进行调整</p><h3 id="7-部署教程"><a href="#7-部署教程" class="headerlink" title="7. 部署教程"></a><strong>7. 部署教程</strong></h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p><a href="https://www.heywhale.com/mw/project/6436d82948f7da1fee2be59e">https://www.heywhale.com/mw/project/6436d82948f7da1fee2be59e</a></p><p>准备工作： 数据集、微调训练方法 P-tuning v2</p><p>基础环境：GPU、pyTorch、模型文件、数据集文件</p><p>验证：使用Langchain进行简单测试验证。</p>]]></content>
    
    
    <categories>
      
      <category>AI技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AI技术-LLMAgent学习笔记</title>
    <link href="/03-LLMAgent%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/03-LLMAgent%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>除了熟知LangChain的基本原理之外，Agent也越来越重要。</p><span id="more"></span>`<h1 id="Agent基本概念"><a href="#Agent基本概念" class="headerlink" title="Agent基本概念"></a>Agent基本概念</h1><p>Planning</p><p>Thinking</p><p>Action</p><p>Memory</p><h1 id="多Agent-Framework"><a href="#多Agent-Framework" class="headerlink" title="多Agent Framework"></a>多Agent Framework</h1><p>MetaGPT</p><img src="https://docs.deepwisdom.ai/main/image/guide/tutorials/multi_agents_flowchart.png" alt="img" style="zoom: 33%;" /><p>核心的元素：观察、提示词+工具、返回结果集成到上下文中。</p><h1 id="semantic-kernel"><a href="#semantic-kernel" class="headerlink" title="semantic kernel"></a>semantic kernel</h1><p>是微软开发的一个基于LLM之上的开发框架，与Langchain类似。但是它从设计上就将function 和prompt 作为一个kerne作为一个原子操作。所以，天然就支持这种workflow的概念。</p><h1 id="GPT-STORE"><a href="#GPT-STORE" class="headerlink" title="GPT STORE"></a>GPT STORE</h1><h2 id="应用市场"><a href="#应用市场" class="headerlink" title="应用市场"></a>应用市场</h2> <img src="/images/chatgpt_store.png" alt="img" style="zoom:20%;" /><h2 id="构建应用"><a href="#构建应用" class="headerlink" title="构建应用"></a>构建应用</h2><ol><li>构建自己的GPT应用</li></ol><img src="/images/chatGPT_builder_configure.png" alt="img" style="zoom:20%;" /><ol start="2"><li>知识库&#x2F;能力&#x2F;外部action能力配置</li></ol><img src="/images/chatGPT_builder_configure_2.png" alt="img" style="zoom:20%;" /><ol start="3"><li><p>action配置的能力</p><p>语法像semantic kernel的语法</p></li></ol><img src="/images/chatGPT_builder_action.png" alt="img" style="zoom:20%;" />]]></content>
    
    
    <categories>
      
      <category>AI技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>agent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI技术-LangChain原理解析</title>
    <link href="/02-langchain/"/>
    <url>/02-langchain/</url>
    
    <content type="html"><![CDATA[<p>最新越发觉得AI的发展，对未来是一场革命，LangChain已经在工程设计上有了最佳实践，类似于AI时代的编程模型或编程框架，有点Spring框架的意思。之前在LangChain上也有些最佳实践，所以在这里分享记录下。</p><span id="more"></span>`<h3 id="LangChain属于哪一层"><a href="#LangChain属于哪一层" class="headerlink" title="LangChain属于哪一层"></a>LangChain属于哪一层</h3><p>​    LangChain是基于LLM之上的，在应用层和底层LLM之前的一个很好的编程框架，如果把LLM比喻为各种类型的数据库、中间件等这些基础设施，应用层是各种业务逻辑的组合之外，那么LangChain就负责桥接与业务层和底层LLM模型，让开发者可以快速地实现对接各种底层模型和快速实现业务逻辑的软件开发框架。</p><p>   那么LangChain是如何做到的呢？试想一下，现在底层有一个大模型的推理能力，除了在对话框手动输入跟他聊天之外。如何用计算机方式跟它互动呢？如果把一次LLM调用当作一个原子能力，如何编排这些原子能力来解决一些业务需求呢？Langchain就是来解决这个事情的。</p><h3 id="LangChain的几个核心概念"><a href="#LangChain的几个核心概念" class="headerlink" title="LangChain的几个核心概念"></a>LangChain的几个核心概念</h3><h4 id="格式化数据（I-x2F-O）"><a href="#格式化数据（I-x2F-O）" class="headerlink" title="格式化数据（I&#x2F;O）"></a>格式化数据（I&#x2F;O）</h4><h4 id="Retriver"><a href="#Retriver" class="headerlink" title="Retriver"></a>Retriver</h4><p>   检索是为了解决大模型打通用户的本身数据，做一些面向业务属性的东西。这里的检索并非传统的关系型数据库，更多的是与大模型的本身逻辑相似的，比如向量数据库。</p><h5 id="一个经典的结合LLM和外部用户的文档进行智能答疑的场景"><a href="#一个经典的结合LLM和外部用户的文档进行智能答疑的场景" class="headerlink" title="一个经典的结合LLM和外部用户的文档进行智能答疑的场景"></a>一个经典的结合LLM和外部用户的文档进行智能答疑的场景</h5><p>文档-&gt;分词-&gt;embedding-&gt;向量数据库</p><p>query-&gt;向量数据库查询-&gt;TOP N-&gt;上下文+ 用户提问 + prompt -&gt; LLM -&gt; 返回结果</p><p>一个经典的图如下：</p><img src="/images/langchain_chatglm.png" alt="img" style="zoom:20%;" /><p><strong>关键技术：文档如何拆分、embedding过程、 TOPN 向量距离的选择</strong></p><p>embedding技术选型</p><p> embedding是将现实中的物体通过向量化的方法转化为高维向量，可被机器学习模型所识别。他是一种映射，同时也保证了能清晰地表达现实物体的特征。基于此，可以进行一些归类分析、回归分析等。</p><p>现在市面上常见的embedding方法有通义千问的embedding等方法。</p><p>向量数据库</p><p>​     向量数据库底层存储的是一堆向量，它提供了根据向量相似度进行查询的能力，一般情况下，向量相似度代表了现实世界中物体的相似度。比如”我的名字是小明“ 和“我叫小明”这两句话所代表的含义几乎是相同的，那么在embedding之后，基于向量数据库进行查询的时候，它们俩的相似度就会很近。</p><p>现在市面上常见的向量数据库有xxx</p><h4 id="Chain"><a href="#Chain" class="headerlink" title="Chain"></a>Chain</h4><p>各种类型的chain，chain代表了各种业务类型的组合，类似于工作流的编排。</p><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><p>LLM本身提供了记忆的能力，同时提供了接口，开发者可以将历史的对话记录传入给LLM。LangChain需要使用外部存储保存这些历史的会话和记忆。可以使用数据库、缓存等进行保存。</p><h4 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h4><h5 id="重点是代理工具"><a href="#重点是代理工具" class="headerlink" title="重点是代理工具"></a>重点是代理工具</h5><p>   代理工具可以让应用程序基于大模型的推理能力，然后进行代理工具或代理服务的调用。因为LLM是没有“联网”的能力的，如果想解决特定的应用场景，代理工具是个完美的选择。</p><p>代理工具通常包含三个方面： 用户输入、prompt编排LLM思考与路由代理的过程、背后的代理服务。其中难点可能就在于prompt设计了。通常的“套路”是这样的：</p><h5 id="ReAct-模型："><a href="#ReAct-模型：" class="headerlink" title="ReAct 模型："></a>ReAct 模型：</h5><p>输入：用户的问题</p><p>思考过程：如果是情况1（这个是需要LLM进行意图识别进行思考的），那么推理和提取出一些关键参数，调用agent1，如果是情况2，那么推理和提取出一些关键参数，调用agent2</p><p>Act：调用agent1对应一个JSON格式化的输入，调用function1，返回结果。</p><p>观察：观察调用后的结果，再结合推理的能力，再进行循环思考。</p><h3 id="LangChain的在实际场景中的实践"><a href="#LangChain的在实际场景中的实践" class="headerlink" title="LangChain的在实际场景中的实践"></a>LangChain的在实际场景中的实践</h3><h4 id="智能问答"><a href="#智能问答" class="headerlink" title="智能问答"></a>智能问答</h4><p>Embedding 是将FAQ的知识库</p><p>prompt+embedding+ 向量数据库+agent </p><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    <categories>
      
      <category>AI技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI,LangChain,LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列-kafka脑裂问题</title>
    <link href="/05-kafka%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98/"/>
    <url>/05-kafka%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了我在公司内遇到的kafka实际难题以及是如何解决的，以此记录一下。</p><span id="more"></span>`<h2 id="什么是脑裂？"><a href="#什么是脑裂？" class="headerlink" title="什么是脑裂？"></a>什么是脑裂？</h2><p>​     脑裂是分布式系统高可用（High Avaliablity）场景下容易出现的问题。我们知道，在分布式系统中常常用多副本来解决容错性问题，多副本中会选举出一个Leader负责与客户端进行交互，但由于各种原因分布式集群中会出现脑裂的情况</p><p>zookeeper脑裂问题 - tantexian的博客空间 - OSCHINAmy.oschina.net&#x2F;tantexian&#x2F;blog&#x2F;2876309</p><p> 这篇文章给出了详细的解释。这里再简单概述以下，基本上是由于网络或者其他原因导致master出现假死，这时候会触发系统进行新的master选举，此时系统中就会出现两个master，产生一系列问题。</p><h2 id="什么是kafka-controller？"><a href="#什么是kafka-controller？" class="headerlink" title="什么是kafka controller？"></a>什么是kafka controller？</h2><p>​    kafka controller相当于整个kafka集群的<strong>master</strong>，负责topic的创建、删除、以及partition的状态机转换，broker的上线、下线等。那么controller是如何选举出来的呢？它是通过抢占方式在zookeeper上注册临时节点来实现的，第一个注册成功的即为controller。关键之处来了，由于<strong>zookeeper临时节点的有效性是通过session来判断的，若在session timeout时间内，controller所在的broker断掉，则会触发新的controller选举。</strong></p><h2 id="kafka-Controller脑裂带来什么问题？"><a href="#kafka-Controller脑裂带来什么问题？" class="headerlink" title="kafka Controller脑裂带来什么问题？"></a>kafka Controller脑裂带来什么问题？</h2><p>什么服务会受到影响？Topic元数据信息新增或者改变时，会在对应的zookeeper path下添加或者更新数据，而controller都对这个路径进行了watch，当有数据变化时，controller会进行partition、replica state的转化，进而对所有存活的broker发送LeaderISR请求，这时第二个controller会发生错误，进而元数据更新失败，对应的partition无法变为online状态。</p><ol><li>创建新的topic成功，客户端往topic内写数据时； </li><li>给某个topic增加分区，zk显示已有增加的分区信息，但是依旧报找不到新增加的分区信息错误</li></ol><p>什么服务不会受到影响？</p><p>  现有的topic读写不受影响，因为读写时获取partition的元数据信息在任意broker上都可以获取到</p><h2 id="什么情况下会导致这个问题？如何解决？"><a href="#什么情况下会导致这个问题？如何解决？" class="headerlink" title="什么情况下会导致这个问题？如何解决？"></a>什么情况下会导致这个问题？如何解决？</h2><ol><li>Controller进行Full GC停顿时间太长超过zookeeper session timeout 出现假死</li><li>Controller 所在broker网络出现故障</li></ol><p>解决方案1：在zk上找到最新的controller所在的broker， 将其余几个过期的controller重启，找其余controller办法，通过上图jmx指标获取value&#x3D;1的 broker</p><p><img src="https://picx.zhimg.com/80/v2-071a5a1f9984922f258d09c589c40ad0_1440w.png?source=d16d100b" alt="img"></p><p>添加图片注释，不超过 140 字（可选）</p><p>解决方案2:</p><p>升级新版本，新版本解决了这个BUG</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>稳定性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo命令详解</title>
    <link href="/09-Hexo/"/>
    <url>/09-Hexo/</url>
    
    <content type="html"><![CDATA[<p>Hexo 是一个基于 Node.js 的静态博客框架，允许你使用 Markdown 编写文章，然后通过 Hexo 生成静态网页。以下是一些常用的 Hexo 命令：</p><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs javascript">初始化博客：<br><br>bash<br><span class="hljs-title class_">Copy</span> code<br>hexo init &lt;folder&gt;<br>cd &lt;folder&gt;<br>用于在指定文件夹中初始化一个 <span class="hljs-title class_">Hexo</span> 博客。<br><br>生成静态文件：<br><br>bash<br><span class="hljs-title class_">Copy</span> code<br>hexo generate<br>用于将 <span class="hljs-title class_">Markdown</span> 文件转换为静态 <span class="hljs-variable constant_">HTML</span> 文件。<br><br>启动本地服务器：<br><br>bash<br><span class="hljs-title class_">Copy</span> code<br>hexo server<br>用于启动一个本地服务器，可以在浏览器中预览生成的静态网页。默认地址是 <span class="hljs-attr">http</span>:<span class="hljs-comment">//localhost:4000。</span><br><br>新建文章：<br><br>bash<br><span class="hljs-title class_">Copy</span> code<br>hexo <span class="hljs-keyword">new</span> [layout] &lt;title&gt;<br>用于新建一篇文章。可选的 layout 参数可以是 post（默认）、page 等。<br><br>部署到远程仓库（如<span class="hljs-title class_">GitHub</span>）：<br><br>bash<br><span class="hljs-title class_">Copy</span> code<br>hexo deploy<br>用于将生成的静态文件部署到配置好的远程仓库。<br><br>清理缓存文件：<br><br>bash<br><span class="hljs-title class_">Copy</span> code<br>hexo clean<br>用于清理 <span class="hljs-title class_">Hexo</span> 生成过程中产生的临时文件。<br><br>查看帮助：<br><br>bash<br><span class="hljs-title class_">Copy</span> code<br>hexo --help<br>用于查看 <span class="hljs-title class_">Hexo</span> 的帮助信息，包括可用命令和选项。<br><br>这些是一些基本的 <span class="hljs-title class_">Hexo</span> 命令，你可以根据需要进一步了解 <span class="hljs-title class_">Hexo</span> 的配置和插件系统以及其他更高级的用法。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
